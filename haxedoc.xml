<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/flash/_std/EReg.hx">
		<customReplace public="1" set="method" line="74">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</customReplace>
		<replace public="1" set="method" line="70">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.</haxe_doc>
		</replace>
		<split public="1" set="method" line="63">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split a string by using the regular expression to match
		the separators.</haxe_doc>
		</split>
		<matchedPos public="1" set="method" line="58">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position of the matched substring within the
		original matched string.</haxe_doc>
		</matchedPos>
		<matchedRight public="1" set="method" line="51">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was at the right of
		of the matched substring.</haxe_doc>
		</matchedRight>
		<matchedLeft public="1" set="method" line="45">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was as the left of
		of the matched substring.</haxe_doc>
		</matchedLeft>
		<matched public="1" set="method" line="41">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the regular expression matches the String.
		Updates the internal state accordingly.</haxe_doc>
		</match>
		<result><c path="+Array"/></result>
		<r><c path="flash.utils.RegExp"/></r>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern [r] and
		options [opt].</haxe_doc>
		</new>
		<haxe_doc>Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/flash/_std/Hash.hx">
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/flash/_std/IntHash.hx">
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an [Array] from an [Iterable]</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a [List] from an [Iterable]</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to [map], but also pass an index for each item iterated.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if at least one element of the iterable is found by using the specific function.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if all elements of the iterable have the specified property defined by [f].</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>Call the function 'f' on all elements of the [Iterable] 'it'.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Return the list of elements matching the function 'f'</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional 'fold' using an [Iterable]</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>Count the number of elements in an [Iterable] having [pred] returning true.</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an iterable does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a list containing all items of 'a' followed by all items of 'b'</haxe_doc>
		</concat>
		<haxe_doc>The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<map public="1" params="X" set="method" line="246">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted
		by the function [f].</haxe_doc>
		</map>
		<filter public="1" set="method" line="230">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].</haxe_doc>
		</filter>
		<join public="1" set="method" line="211">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Join the element of the list by using the separator [sep].</haxe_doc>
		</join>
		<toString public="1" set="method" line="191">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Makes the list empty.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="98">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<last public="1" set="method" line="88">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of the list, or null
		if the list is empty.</haxe_doc>
		</last>
		<first public="1" set="method" line="80">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Push an element at the beginning of the list.</haxe_doc>
		</push>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the end of the list.</haxe_doc>
		</add>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="51" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="59" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="63" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="86" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="90" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="96" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="115" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="121" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="48" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addSub public="1" get="inline" set="null" line="56">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="49">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<add public="1" get="inline" set="null" line="42">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="String"/></b>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="89" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="93" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="117" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="134" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="155" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="168" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="180" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="186" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="203" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="207" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="214" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="219" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="251" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="268" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="272" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="276" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="280" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/flash/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="/usr/lib/haxe/std/flash/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="49" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parse a String into an Xml object.</haxe_doc>
		</parse>
		<compare set="method" line="71" static="1">
			<f a="a:b">
				<c path="Xml"/>
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
		</compare>
		<createElement public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="81" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="86" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="90" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="95" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="99" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="104" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<getNodeType set="method" line="108" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
</f></getNodeType>
		<wrap set="method" line="184" static="1"><f a="node:?type">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
	<c path="Xml"/>
</f></wrap>
		<toString public="1" set="method" line="389">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<insertChild public="1" set="method" line="379">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.</haxe_doc>
		</insertChild>
		<removeChild public="1" set="method" line="368">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<addChild public="1" set="method" line="361">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.</haxe_doc>
		</addChild>
		<firstElement public="1" set="method" line="352">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<firstChild public="1" set="method" line="343">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<elementsNamed public="1" set="method" line="318">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<elements public="1" set="method" line="302">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<iterator public="1" set="method" line="286">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<attributes public="1" set="method" line="270">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an [Iterator] on all the attribute names.</haxe_doc>
		</attributes>
		<exists public="1" set="method" line="259">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<remove public="1" set="method" line="249">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<set public="1" set="method" line="228">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<get public="1" set="method" line="211">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<getAttribNS set="method" line="198"><f a="cur:ns">
	<c path="flash.xml.XML"/>
	<c path="Array"><c path="String"/></c>
	<c path="flash.xml.XMLList"/>
</f></getAttribNS>
		<wraps set="method" line="191"><f a="xList">
	<c path="flash.xml.XMLList"/>
	<c path="Array"><c path="Xml"/></c>
</f></wraps>
		<getParent set="method" line="179"><f a=""><c path="Xml"/></f></getParent>
		<setNodeValue set="method" line="153"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getNodeValue set="method" line="144"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeName set="method" line="131"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeName set="method" line="124"><f a=""><c path="String"/></f></getNodeName>
		<_node><c path="flash.xml.XML"/></_node>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.</haxe_doc>
		</parent>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<new set="method" line="75"><f a=""><e path="Void"/></f></new>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="nme.display.Tilesheet" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="59" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="60" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="61" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="62" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="66" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="69" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="70" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<defaultRatio line="77" static="1"><t path="nme.geom.Point"/></defaultRatio>
		<drawTiles public="1" set="method" line="193">
			<f a="graphics:tileData:?smooth:?flags">
				<t path="nme.display.Graphics"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fast method to draw a batch of tiles using a Tilesheet
	 * 
	 * The input array accepts the x, y and tile ID for each tile you wish to draw.
	 * For example, an array of [ 0, 0, 0, 10, 10, 1 ] would draw tile 0 to (0, 0) and
	 * tile 1 to (10, 10)
	 * 
	 * You can also set flags for TILE_SCALE, TILE_ROTATION, TILE_RGB and
	 * TILE_ALPHA.
	 * 
	 * Depending on which flags are active, this is the full order of the array:
	 * 
	 * [ x, y, tile ID, scale, rotation, red, green, blue, alpha, x, y ... ]
	 * 
	 * @param	graphics		The native.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether drawn tiles should be smoothed (Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing (Default: 0)</haxe_doc>
		</drawTiles>
		<adjustLen set="method" line="162"><f a="vec:len">
	<t path="nme.Vector"><c path="Float"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Float"/></t>
</f></adjustLen>
		<adjustIndices set="method" line="131"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIndices>
		<adjustIDs set="method" line="116"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIDs>
		<addTileRect public="1" set="method" line="107"><f a="rectangle:?centerPoint">
	<t path="nme.geom.Rectangle"/>
	<t path="nme.geom.Point"/>
	<e path="Void"/>
</f></addTileRect>
		<_uvs><t path="nme.Vector"><c path="Float"/></t></_uvs>
		<_indices><t path="nme.Vector"><c path="Int"/></t></_indices>
		<_vertices><t path="nme.Vector"><c path="Float"/></t></_vertices>
		<_ids><t path="nme.Vector"><c path="Int"/></t></_ids>
		<tileUVs><c path="Array"><t path="nme.geom.Rectangle"/></c></tileUVs>
		<tiles><c path="Array"><t path="nme.geom.Rectangle"/></c></tiles>
		<tilePoints><c path="Array"><t path="nme.geom.Point"/></c></tilePoints>
		<bitmapWidth><c path="Int"/></bitmapWidth>
		<bitmapHeight><c path="Int"/></bitmapHeight>
		<nmeBitmap public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* @private</haxe_doc>
		</nmeBitmap>
		<new public="1" set="method" line="89"><f a="inImage">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="aze.display.TilesheetEx" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/TilesheetEx.hx">
		<extends path="nme.display.Tilesheet"/>
		<createFromAssets public="1" set="method" line="84" static="1"><f a="fileNames:?padding:?spacing">
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<c path="aze.display.TilesheetEx"/>
</f></createFromAssets>
		<createFromImages public="1" set="method" line="98" static="1"><f a="names:images:?padding:?spacing">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><t path="nme.display.BitmapData"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<c path="aze.display.TilesheetEx"/>
</f></createFromImages>
		<closestPow2 public="1" set="method" line="130" static="1"><f a="v">
	<c path="Int"/>
	<c path="Int"/>
</f></closestPow2>
		<getBitmap public="1" get="inline" set="null" line="78"><f a="indice">
	<c path="Int"/>
	<t path="nme.display.BitmapData"/>
</f></getBitmap>
		<getSize public="1" get="inline" set="null" line="71"><f a="indice">
	<c path="Int"/>
	<t path="nme.geom.Rectangle"/>
</f></getSize>
		<getAnim public="1" set="method" line="57"><f a="name">
	<c path="String"/>
	<c path="Array"><c path="Int"/></c>
</f></getAnim>
		<addDefinition set="method" line="42"><f a="name:size:bmp">
	<c path="String"/>
	<t path="nme.geom.Rectangle"/>
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></addDefinition>
		<bmps><c path="Array"><t path="nme.display.BitmapData"/></c></bmps>
		<anims><c path="Hash"><c path="Array"><c path="Int"/></c></c></anims>
		<sizes><c path="Array"><t path="nme.geom.Rectangle"/></c></sizes>
		<defs><c path="Array"><c path="String"/></c></defs>
		<new public="1" set="method" line="29"><f a="img">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* A cross-targets Tilesheet container, with animation and trimming support
 *
 * - animations are matched by name (startsWith) and cached after 1st request,
 * - rect: marks the actual pixel content of the spritesheet that should be displayed for a sprite,
 * - size: original (before trimming) sprite dimensions are indicated by the size's (width,height); 
 *         rect offset inside the original sprite is indicated by size's (left,top).
 *
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="aze.display.SparrowTilesheet" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/SparrowTilesheet.hx">
		<extends path="aze.display.TilesheetEx"/>
		<new public="1" set="method" line="18"><f a="img:xml">
	<t path="nme.display.BitmapData"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Sparrow spritesheet parser for TileLayer
 * - supports animations
 * - supports sprite trimming
 * - does NOT support sprite rotation
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="haxe.Public" params="" file="/usr/lib/haxe/std/haxe/Public.hx" interface="1"><haxe_doc>When implementing this interface, all default fields access for the class and
	subclasses becomes [public] instead of [private].</haxe_doc></class>
	<class path="aze.display.TileBase" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/TileLayer.hx" module="aze.display.TileLayer">
		<implements path="haxe.Public"/>
		<getView public="1" set="method" line="177"><f a=""><t path="nme.display.DisplayObject"/></f></getView>
		<step public="1" set="method" line="172"><f a="elapsed">
	<c path="Int"/>
	<e path="Void"/>
</f></step>
		<init public="1" set="method" line="167"><f a="layer">
	<c path="aze.display.TileLayer"/>
	<e path="Void"/>
</f></init>
		<visible public="1"><e path="Bool"/></visible>
		<animated public="1"><e path="Bool"/></animated>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<parent public="1"><c path="aze.display.TileGroup"/></parent>
		<layer public="1"><c path="aze.display.TileLayer"/></layer>
		<new public="1" set="method" line="161"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private base tile type</haxe_doc>
	</class>
	<class path="aze.display.TileSprite" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/TileSprite.hx">
		<extends path="aze.display.TileBase"/>
		<get_width get="inline" set="null" line="226"><f a=""><c path="Float"/></f></get_width>
		<width public="1" get="get_width" set="null"><c path="Float"/></width>
		<get_height get="inline" set="null" line="221"><f a=""><c path="Float"/></f></get_height>
		<height public="1" get="get_height" set="null"><c path="Float"/></height>
		<get_matrix set="method" line="193"><f a=""><t path="nme.geom.Matrix"/></f></get_matrix>
		<matrix public="1" get="get_matrix" set="null"><t path="nme.geom.Matrix"/></matrix>
		<set_color set="method" line="156"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_color>
		<get_color set="method" line="150"><f a=""><c path="Int"/></f></get_color>
		<color public="1" get="get_color" set="set_color"><c path="Int"/></color>
		<set_scaleY set="method" line="140"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_scaleY>
		<get_scaleY get="inline" set="null" line="139"><f a=""><c path="Float"/></f></get_scaleY>
		<scaleY public="1" get="get_scaleY" set="set_scaleY"><c path="Float"/></scaleY>
		<set_scaleX set="method" line="129"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_scaleX>
		<get_scaleX get="inline" set="null" line="128"><f a=""><c path="Float"/></f></get_scaleX>
		<scaleX public="1" get="get_scaleX" set="set_scaleX"><c path="Float"/></scaleX>
		<set_scale set="method" line="117"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_scale>
		<get_scale get="inline" set="null" line="116"><f a=""><c path="Float"/></f></get_scale>
		<scale public="1" get="get_scale" set="set_scale"><c path="Float"/></scale>
		<set_rotation set="method" line="106"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_rotation>
		<get_rotation get="inline" set="null" line="105"><f a=""><c path="Float"/></f></get_rotation>
		<rotation public="1" get="get_rotation" set="set_rotation"><c path="Float"/></rotation>
		<set_mirror set="method" line="95"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_mirror>
		<get_mirror get="inline" set="null" line="94"><f a=""><c path="Int"/></f></get_mirror>
		<mirror public="1" get="get_mirror" set="set_mirror"><c path="Int"/></mirror>
		<set_indice set="method" line="80"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_indice>
		<get_indice get="inline" set="null" line="79"><f a=""><c path="Int"/></f></get_indice>
		<indice public="1" get="get_indice" set="set_indice"><c path="Int"/></indice>
		<set_tile set="method" line="69"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_tile>
		<get_tile get="inline" set="null" line="68"><f a=""><c path="String"/></f></get_tile>
		<tile public="1" get="get_tile" set="set_tile"><c path="String"/></tile>
		<getView public="1" set="method" line="64" override="1"><f a=""><t path="nme.display.DisplayObject"/></f></getView>
		<init public="1" set="method" line="55" override="1"><f a="layer">
	<c path="aze.display.TileLayer"/>
	<e path="Void"/>
</f></init>
		<b public="1"><c path="Float"/></b>
		<g public="1"><c path="Float"/></g>
		<r public="1"><c path="Float"/></r>
		<alpha public="1"><c path="Float"/></alpha>
		<bmp public="1"><t path="nme.display.Bitmap"/></bmp>
		<_matrix><t path="nme.geom.Matrix"/></_matrix>
		<_mirror><c path="Int"/></_mirror>
		<_scaleY><c path="Float"/></_scaleY>
		<_scaleX><c path="Float"/></_scaleX>
		<_rotation><c path="Float"/></_rotation>
		<dirty><e path="Bool"/></dirty>
		<size><t path="nme.geom.Rectangle"/></size>
		<_indice><c path="Int"/></_indice>
		<_tile><c path="String"/></_tile>
		<new public="1" set="method" line="37"><f a="tile">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Static tile for TileLayer
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="aze.display.TileClip" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/TileClip.hx">
		<extends path="aze.display.TileSprite"/>
		<get_totalFrames public="1" get="inline" set="null" line="88"><f a=""><c path="Int"/></f></get_totalFrames>
		<totalFrames public="1" get="get_totalFrames" set="null"><c path="Int"/></totalFrames>
		<set_currentFrame public="1" set="method" line="78"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_currentFrame>
		<get_currentFrame public="1" set="method" line="73"><f a=""><c path="Int"/></f></get_currentFrame>
		<currentFrame public="1" get="get_currentFrame" set="set_currentFrame"><c path="Int"/></currentFrame>
		<stop public="1" set="method" line="69"><f a=""><e path="Void"/></f></stop>
		<play public="1" set="method" line="57"><f a=""><e path="Void"/></f></play>
		<step public="1" set="method" line="37" override="1"><f a="elapsed">
	<c path="Int"/>
	<e path="Void"/>
</f></step>
		<init public="1" set="method" line="29" override="1"><f a="layer">
	<c path="aze.display.TileLayer"/>
	<e path="Void"/>
</f></init>
		<prevFrame public="1"><c path="Int"/></prevFrame>
		<time public="1"><c path="Int"/></time>
		<loop public="1"><e path="Bool"/></loop>
		<fps public="1"><c path="Int"/></fps>
		<frames public="1"><c path="Array"><c path="Int"/></c></frames>
		<onComplete public="1"><f a="">
	<c path="aze.display.TileClip"/>
	<e path="Void"/>
</f></onComplete>
		<new public="1" set="method" line="20"><f a="tile:?fps">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Animated tile for TileLayer
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="aze.display.TileGroup" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/TileGroup.hx">
		<extends path="aze.display.TileBase"/>
		<get_width set="method" line="147"><f a=""><c path="Float"/></f></get_width>
		<width public="1" get="get_width" set="null"><c path="Float"/></width>
		<get_height set="method" line="130"><f a=""><c path="Float"/></f></get_height>
		<height public="1" get="get_height" set="null"><c path="Float"/></height>
		<get_numChildren get="inline" set="null" line="127"><f a=""><c path="Int"/></f></get_numChildren>
		<numChildren public="1" get="get_numChildren" set="null"><c path="Int"/></numChildren>
		<iterator public="1" get="inline" set="null" line="124"><f a=""><t path="Iterator"><c path="aze.display.TileBase"/></t></f></iterator>
		<getChildIndex public="1" set="method" line="119"><f a="item">
	<c path="aze.display.TileBase"/>
	<c path="Int"/>
</f></getChildIndex>
		<removeAllChildren public="1" set="method" line="109"><f a=""><c path="Array"><c path="aze.display.TileBase"/></c></f></removeAllChildren>
		<removeChildAt public="1" set="method" line="99"><f a="index">
	<c path="Int"/>
	<c path="aze.display.TileBase"/>
</f></removeChildAt>
		<removeChild public="1" set="method" line="80"><f a="item">
	<c path="aze.display.TileBase"/>
	<c path="aze.display.TileBase"/>
</f></removeChild>
		<addChildAt public="1" set="method" line="69"><f a="item:index">
	<c path="aze.display.TileBase"/>
	<c path="Int"/>
	<c path="Int"/>
</f></addChildAt>
		<addChild public="1" set="method" line="59"><f a="item">
	<c path="aze.display.TileBase"/>
	<c path="Int"/>
</f></addChild>
		<indexOf public="1" get="inline" set="null" line="54"><f a="item">
	<c path="aze.display.TileBase"/>
	<c path="Int"/>
</f></indexOf>
		<initChildren set="method" line="48"><f a=""><e path="Void"/></f></initChildren>
		<initChild set="method" line="41"><f a="item">
	<c path="aze.display.TileBase"/>
	<e path="Void"/>
</f></initChild>
		<getView public="1" set="method" line="38" override="1"><f a=""><t path="nme.display.DisplayObject"/></f></getView>
		<init public="1" set="method" line="31" override="1"><f a="layer">
	<c path="aze.display.TileLayer"/>
	<e path="Void"/>
</f></init>
		<container><t path="nme.display.Sprite"/></container>
		<children public="1"><c path="Array"><c path="aze.display.TileBase"/></c></children>
		<new public="1" set="method" line="22"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Tiles container for TileLayer
 * - can contain types compatible with TileSprite or TileGroup
 * - only offers x/y position offset to its content
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="aze.display.TileLayer" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/TileLayer.hx">
		<extends path="aze.display.TileGroup"/>
		<synchronizedElapsed static="1"><c path="Float"/></synchronizedElapsed>
		<renderGroup set="method" line="66"><f a="group:index:gx:gy">
	<c path="aze.display.TileGroup"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></renderGroup>
		<render public="1" set="method" line="52"><f a="?elapsed">
	<c path="Int"/>
	<c path="Int"/>
</f></render>
		<drawList><c path="aze.display.DrawList"/></drawList>
		<tilesheet public="1"><c path="aze.display.TilesheetEx"/></tilesheet>
		<useTint public="1"><e path="Bool"/></useTint>
		<useTransforms public="1"><e path="Bool"/></useTransforms>
		<useAlpha public="1"><e path="Bool"/></useAlpha>
		<useAdditive public="1"><e path="Bool"/></useAdditive>
		<useSmoothing public="1"><e path="Bool"/></useSmoothing>
		<view public="1"><t path="nme.display.Sprite"/></view>
		<new public="1" set="method" line="34"><f a="tilesheet:?smooth:?additive">
	<c path="aze.display.TilesheetEx"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* A little wrapper of NME's Tilesheet rendering (for native platform)
 * and using Bitmaps for Flash platform.
 * Features basic containers (TileGroup) and spritesheets animations.
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="aze.display.DrawList" params="" file="/Users/jbrichardet/Development/nme-tilelayer/haxelib/aze/display/TileLayer.hx" module="aze.display.TileLayer">
		<implements path="haxe.Public"/>
		<end public="1" set="method" line="244"><f a=""><e path="Void"/></f></end>
		<begin public="1" set="method" line="205"><f a="elapsed:useTransforms:useAlpha:useTint:useAdditive">
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></begin>
		<runs public="1"><c path="Int"/></runs>
		<elapsed public="1"><c path="Int"/></elapsed>
		<time public="1"><c path="Int"/></time>
		<flags public="1"><c path="Int"/></flags>
		<offsetAlpha public="1"><c path="Int"/></offsetAlpha>
		<offsetRGB public="1"><c path="Int"/></offsetRGB>
		<offsetTransform public="1"><c path="Int"/></offsetTransform>
		<fields public="1"><c path="Int"/></fields>
		<index public="1"><c path="Int"/></index>
		<list public="1"><c path="Array"><c path="Float"/></c></list>
		<new public="1" set="method" line="198"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private render buffer</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.IGenericActuator" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/GenericActuator.hx" module="com.eclecticdesignstudio.motion.actuators.GenericActuator" interface="1">
		<snapping public="1" set="method">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Snapping causes tween values to be rounded automatically
	 * @param	value		Whether tween values should be rounded (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</snapping>
		<smartRotation public="1" set="method">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Enabling smartRotation can prevent undesired results when tweening rotation values
	 * @param	value		Whether smart rotation should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</smartRotation>
		<reverse public="1" set="method">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets if the tween should be handled in reverse
	 * @param	value		Whether the tween should be reversed (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reverse>
		<repeat public="1" set="method">
			<f a="?times">
				<c path="Int"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Repeats the tween after it finishes
	 * @param	times		The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
	 * @return		The current actuator instance</haxe_doc>
		</repeat>
		<reflect public="1" set="method">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
	 * @param	value		Whether reflect should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reflect>
		<onUpdate public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween updates
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onUpdate>
		<onRepeat public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween repeats
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onRepeat>
		<onComplete public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween finishes
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onComplete>
		<ease public="1" set="method">
			<f a="easing">
				<c path="com.eclecticdesignstudio.motion.easing.IEasing"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets the easing which is used when running the tween
	 * @param	easing		An easing equation, like Elastic.easeIn or Quad.easeOut
	 * @return		The current actuator instance</haxe_doc>
		</ease>
		<delay public="1" set="method">
			<f a="duration">
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Increases the delay before a tween is executed
	 * @param	duration		The amount of seconds to delay
	 * @return		The current actuator instance</haxe_doc>
		</delay>
		<autoVisible public="1" set="method">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
	 * @param	value		Whether autoVisible should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</autoVisible>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.GenericActuator" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/GenericActuator.hx">
		<implements path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
		<stop public="1" set="method" line="389"><f a="properties:complete:sendEvent">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<snapping public="1" set="method" line="373">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Snapping causes tween values to be rounded automatically
	 * @param	value		Whether tween values should be rounded (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</snapping>
		<smartRotation public="1" set="method" line="352">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Enabling smartRotation can prevent undesired results when tweening rotation values
	 * @param	value		Whether smart rotation should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</smartRotation>
		<reverse public="1" set="method" line="331">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets if the tween should be handled in reverse
	 * @param	value		Whether the tween should be reversed (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reverse>
		<resume public="1" set="method" line="319"><f a=""><e path="Void"/></f></resume>
		<repeat public="1" set="method" line="304">
			<f a="?times">
				<c path="Int"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Repeats the tween after it finishes
	 * @param	times		The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
	 * @return		The current actuator instance</haxe_doc>
		</repeat>
		<reflect public="1" set="method" line="283">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
	 * @param	value		Whether reflect should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reflect>
		<pause public="1" set="method" line="271"><f a=""><e path="Void"/></f></pause>
		<onUpdate public="1" set="method" line="252">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween updates
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onUpdate>
		<onRepeat public="1" set="method" line="227">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween repeats
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onRepeat>
		<onComplete public="1" set="method" line="196">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween finishes
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onComplete>
		<move public="1" set="method" line="183"><f a=""><e path="Void"/></f></move>
		<ease public="1" set="method" line="174">
			<f a="easing">
				<c path="com.eclecticdesignstudio.motion.easing.IEasing"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets the easing which is used when running the tween
	 * @param	easing		An easing equation, like Elastic.easeIn or Quad.easeOut
	 * @return		The current actuator instance</haxe_doc>
		</ease>
		<delay public="1" set="method" line="160">
			<f a="duration">
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Increases the delay before a tween is executed
	 * @param	duration		The amount of seconds to delay
	 * @return		The current actuator instance</haxe_doc>
		</delay>
		<complete set="method" line="127"><f a="?sendEvent">
	<e path="Bool"/>
	<e path="Void"/>
</f></complete>
		<change set="method" line="107"><f a=""><e path="Void"/></f></change>
		<autoVisible public="1" set="method" line="92">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
	 * @param	value		Whether autoVisible should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</autoVisible>
		<apply public="1" set="method" line="60"><f a=""><e path="Void"/></f></apply>
		<special><e path="Bool"/></special>
		<_snapping><e path="Bool"/></_snapping>
		<_smartRotation><e path="Bool"/></_smartRotation>
		<_reverse><e path="Bool"/></_reverse>
		<_repeat><c path="Int"/></_repeat>
		<_reflect><e path="Bool"/></_reflect>
		<_onUpdateParams><c path="Array"><d/></c></_onUpdateParams>
		<_onUpdate><d/></_onUpdate>
		<_onRepeatParams><c path="Array"><d/></c></_onRepeatParams>
		<_onRepeat><d/></_onRepeat>
		<_onCompleteParams><c path="Array"><d/></c></_onCompleteParams>
		<_onComplete><d/></_onComplete>
		<_ease><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></_ease>
		<_delay><c path="Float"/></_delay>
		<_autoVisible><e path="Bool"/></_autoVisible>
		<target public="1"><d/></target>
		<properties public="1"><d/></properties>
		<id public="1"><c path="String"/></id>
		<duration public="1"><c path="Float"/></duration>
		<new public="1" set="method" line="40"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.SimpleActuator" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/SimpleActuator.hx">
		<extends path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
		<actuators line="22" static="1"><c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.SimpleActuator"/></c></actuators>
		<actuatorsLength line="23" static="1"><c path="Int"/></actuatorsLength>
		<shape static="1"><c path="flash.display.Shape"/></shape>
		<shape_onEnterFrame set="method" line="428" static="1"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></shape_onEnterFrame>
		<update set="method" line="241"><f a="currentTime">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<stop public="1" set="method" line="198" override="1"><f a="properties:complete:sendEvent">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<resume public="1" set="method" line="186" override="1"><f a=""><e path="Void"/></f></resume>
		<pause public="1" set="method" line="178" override="1"><f a=""><e path="Void"/></f></pause>
		<onUpdate public="1" set="method" line="167" override="1">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</onUpdate>
		<move public="1" set="method" line="145" override="1"><f a=""><e path="Void"/></f></move>
		<initialize set="method" line="106"><f a=""><e path="Void"/></f></initialize>
		<delay public="1" set="method" line="96" override="1">
			<f a="duration">
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</delay>
		<autoVisible public="1" set="method" line="66" override="1">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</autoVisible>
		<toggleVisible><e path="Bool"/></toggleVisible>
		<startTime><c path="Float"/></startTime>
		<setVisible><e path="Bool"/></setVisible>
		<sendChange><e path="Bool"/></sendChange>
		<propertyDetails><c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.PropertyDetails"/></c></propertyDetails>
		<pauseTime><c path="Float"/></pauseTime>
		<paused><e path="Bool"/></paused>
		<initialized><e path="Bool"/></initialized>
		<detailsLength><c path="Int"/></detailsLength>
		<cacheVisible><e path="Bool"/></cacheVisible>
		<active><e path="Bool"/></active>
		<timeOffset><c path="Float"/></timeOffset>
		<new public="1" set="method" line="39"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.Expo" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Expo.hx">
		<easeIn public="1" get="get_easeIn" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeIn>
		<easeInOut public="1" get="get_easeInOut" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeInOut>
		<easeOut public="1" get="get_easeOut" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeOut>
		<get_easeIn set="method" line="19" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></get_easeIn>
		<get_easeInOut set="method" line="26" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></get_easeInOut>
		<get_easeOut set="method" line="33" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></get_easeOut>
		<haxe_doc>* @author Joshua Granick
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.IEasing" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/IEasing.hx" interface="1">
		<ease public="1" set="method"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<calculate public="1" set="method"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<haxe_doc>* @author Joshua Granick
	 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.ExpoEaseOut" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Expo.hx" module="com.eclecticdesignstudio.motion.easing.Expo">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<ease public="1" set="method" line="128"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="121"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<new public="1" set="method" line="114"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion._Actuate.ObjectHash" params="T" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/Actuate.hx" private="1" module="com.eclecticdesignstudio.motion.Actuate">
		<nextObjectID line="579" static="1"><c path="Int"/></nextObjectID>
		<set public="1" get="inline" set="null" line="696"><f a="key:value">
	<d/>
	<c path="com.eclecticdesignstudio.motion._Actuate.ObjectHash.T"/>
	<e path="Void"/>
</f></set>
		<remove public="1" get="inline" set="null" line="681"><f a="key">
	<d/>
	<e path="Void"/>
</f></remove>
		<iterator public="1" get="inline" set="null" line="658"><f a=""><t path="Iterator"><c path="com.eclecticdesignstudio.motion._Actuate.ObjectHash.T"/></t></f></iterator>
		<getID get="inline" set="null" line="627"><f a="key">
	<d/>
	<c path="Int"/>
</f></getID>
		<get public="1" get="inline" set="null" line="612"><f a="key">
	<d/>
	<c path="com.eclecticdesignstudio.motion._Actuate.ObjectHash.T"/>
</f></get>
		<exists public="1" get="inline" set="null" line="597"><f a="key">
	<d/>
	<e path="Bool"/>
</f></exists>
		<dictionary><c path="flash.utils.TypedDictionary">
	<d/>
	<c path="com.eclecticdesignstudio.motion._Actuate.ObjectHash.T"/>
</c></dictionary>
		<new public="1" set="method" line="582"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.utils.TypedDictionary" params="K:T" file="/usr/lib/haxe/std/flash/utils/TypedDictionary.hx">
		<extends path="flash.utils.Dictionary"/>
		<iterator public="1" set="method" line="52"><f a=""><t path="Iterator"><c path="flash.utils.TypedDictionary.K"/></t></f></iterator>
		<keys public="1" get="inline" set="null" line="48"><f a=""><c path="Array"><c path="flash.utils.TypedDictionary.K"/></c></f></keys>
		<delete public="1" get="inline" set="null" line="44"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<e path="Void"/>
</f></delete>
		<exists public="1" get="inline" set="null" line="40"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<e path="Bool"/>
</f></exists>
		<set public="1" get="inline" set="null" line="36"><f a="k:v">
	<c path="flash.utils.TypedDictionary.K"/>
	<c path="flash.utils.TypedDictionary.T"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="32"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<t path="Null"><c path="flash.utils.TypedDictionary.T"/></t>
</f></get>
		<new public="1" set="method" line="30"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>This is a typed version of the Flash9 Dictionary class.</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.Actuate" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/Actuate.hx">
		<defaultActuator public="1" line="28" static="1"><c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c></defaultActuator>
		<defaultEase public="1" line="29" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></defaultEase>
		<targetLibraries line="30" static="1"><c path="com.eclecticdesignstudio.motion._Actuate.ObjectHash"><c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c></c></targetLibraries>
		<apply public="1" set="method" line="41" static="1">
			<f a="target:properties:?customActuator">
				<d/>
				<d/>
				<c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Copies properties from one object to another. Conflicting tweens are stopped automatically
	 * @example		<code>Actuate.apply (MyClip, { alpha: 1 } );</code>
	 * @param	target		The object to copy to
	 * @param	properties		The object to copy from
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like onComplete or onUpdate handlers]]></haxe_doc>
		</apply>
		<createInstance set="method" line="59" static="1"><f a="actuator:target:duration:properties">
	<c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
	<d/>
	<c path="Float"/>
	<d/>
	<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
</f></createInstance>
		<effects public="1" set="method" line="105" static="1">
			<f a="target:duration:?overwrite">
				<c path="flash.display.DisplayObject"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion._Actuate.EffectsOptions"/>
			</f>
			<haxe_doc>* Creates a new effects tween 
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		An EffectsOptions instance, which is used to select the kind of effect you would like to apply to the target</haxe_doc>
		</effects>
		<getLibrary set="method" line="112" static="1"><f a="target">
	<d/>
	<c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
</f></getLibrary>
		<motionPath public="1" set="method" line="133" static="1">
			<f a="target:duration:properties:?overwrite">
				<d/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Creates a new MotionPath tween
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	properties		An object containing a motion path for each property you wish to tween
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate</haxe_doc>
		</motionPath>
		<pause public="1" set="method" line="145" static="1">
			<f a="target">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Pauses tweens for the specified target objects
	 * @param	... targets		The target objects which will have their tweens paused. Passing no value pauses tweens for all objects</haxe_doc>
		</pause>
		<pauseAll public="1" set="method" line="166" static="1"><f a=""><e path="Void"/></f></pauseAll>
		<reset public="1" set="method" line="184" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resets Actuate by stopping and removing tweens for all objects</haxe_doc>
		</reset>
		<resume public="1" set="method" line="205" static="1">
			<f a="target">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Resumes paused tweens for the specified target objects
	 * @param	... targets		The target objects which will have their tweens resumed. Passing no value resumes tweens for all objects</haxe_doc>
		</resume>
		<resumeAll public="1" set="method" line="226" static="1"><f a=""><e path="Void"/></f></resumeAll>
		<stop public="1" set="method" line="248" static="1">
			<f a="target:?properties:?complete:?sendEvent">
				<d/>
				<d/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Stops all tweens for an individual object
	 * @param	target		The target object which will have its tweens stopped, or a generic actuator instance
	 * @param  properties		A string, array or object which contains the properties you wish to stop, like "alpha", [ "x", "y" ] or { alpha: null }. Passing no value removes all tweens for the object (Optional)
	 * @param	complete		If tweens should apply their final target values before stopping. Default is false (Optional) 
	 * @param	sendEvent	If a complete() event should be dispatched for the specified target. Default is true (Optional)</haxe_doc>
		</stop>
		<timer public="1" set="method" line="300" static="1">
			<f a="duration:?customActuator">
				<c path="Float"/>
				<c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a tween-based timer, which is useful for synchronizing function calls with other animations
	 * @example		<code>Actuate.timer (1).onComplete (trace, [ "Timer is now complete" ]);</code>
	 * @param	duration		The length of the timer in seconds
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like onComplete or to gain a reference to the target timer object]]></haxe_doc>
		</timer>
		<transform public="1" set="method" line="315" static="1">
			<f a="target:?duration:?overwrite">
				<d/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion._Actuate.TransformOptions"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new transform tween
	 * @example		<code>Actuate.transform (MyClip, 1).color (0xFF0000);</code>
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		A TransformOptions instance, which is used to select the kind of transform you would like to apply to the target]]></haxe_doc>
		</transform>
		<tween public="1" set="method" line="332" static="1">
			<f a="target:duration:properties:?overwrite:?customActuator">
				<d/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new tween
	 * @example		<code>Actuate.tween (MyClip, 1, { alpha: 1 } ).onComplete (trace, [ "MyClip is now visible" ]);</code>
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	properties		The end values to tween the target to
	 * @param	overwrite			Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate]]></haxe_doc>
		</tween>
		<unload public="1" set="method" line="388" static="1"><f a="actuator">
	<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
	<e path="Void"/>
</f></unload>
		<update public="1" set="method" line="417" static="1">
			<f a="target:duration:?start:?end:?overwrite">
				<d/>
				<c path="Float"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new tween that updates a method rather than setting the properties of an object
	 * @example		<code>Actuate.update (trace, 1, ["Value: ", 0], ["", 1]).onComplete (trace, [ "Finished tracing values between 0 and 1" ]);</code>
	 * @param	target		The method to update		
	 * @param	duration		The length of the tween in seconds
	 * @param	start		The starting parameters of the method call. You may use both numeric and non-numeric values
	 * @param	end		The ending parameters of the method call. You may use both numeric and non-numeric values, but the signature should match the start parameters
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate]]></haxe_doc>
		</update>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion._Actuate.EffectsOptions" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/Actuate.hx" private="1" module="com.eclecticdesignstudio.motion.Actuate">
		<filter public="1" set="method" line="464">
			<f a="reference:properties">
				<d/>
				<d/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Creates a new BitmapFilter tween
	 * @param	reference		A reference to the target's filter, which can be an array index or the class of the filter
	 * @param	properties		The end properties to use for the tween
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate</haxe_doc>
		</filter>
		<target><c path="flash.display.DisplayObject"/></target>
		<overwrite><e path="Bool"/></overwrite>
		<duration><c path="Float"/></duration>
		<new public="1" set="method" line="449"><f a="target:duration:overwrite">
	<c path="flash.display.DisplayObject"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion._Actuate.TransformOptions" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/Actuate.hx" private="1" module="com.eclecticdesignstudio.motion.Actuate">
		<sound public="1" set="method" line="521">
			<f a="?volume:?pan">
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Creates a new SoundTransform tween
	 * @param	volume		The end volume for the target, or null if you would like to ignore this property (Default is null)
	 * @param	pan		The end pan for the target, or null if you would like to ignore this property (Default is null)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate</haxe_doc>
		</sound>
		<color public="1" set="method" line="500">
			<f a="?value:?strength:?alpha">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Creates a new ColorTransform tween
	 * @param	color		The color value
	 * @param	strength		The percentage amount of tint to apply (Default is 1)
	 * @param	alpha		The end alpha of the target. If you wish to tween alpha and tint simultaneously, you must do them both as part of the ColorTransform. A value of null will make no change to the alpha of the object (Default is null)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate</haxe_doc>
		</color>
		<target><d/></target>
		<overwrite><e path="Bool"/></overwrite>
		<duration><c path="Float"/></duration>
		<new public="1" set="method" line="484"><f a="target:duration:overwrite">
	<d/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion._Actuate.TweenTimer" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/Actuate.hx" private="1" module="com.eclecticdesignstudio.motion.Actuate">
		<progress public="1"><c path="Float"/></progress>
		<new public="1" set="method" line="551"><f a="progress">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.MotionPath" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/MotionPath.hx">
		<get_y set="method" line="75"><f a=""><c path="com.eclecticdesignstudio.motion.IComponentPath"/></f></get_y>
		<get_x set="method" line="68"><f a=""><c path="com.eclecticdesignstudio.motion.IComponentPath"/></f></get_x>
		<line public="1" set="method" line="51">
			<f a="x:y:?strength">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.MotionPath"/>
			</f>
			<haxe_doc>* Adds a line to the current motion path
	 * @param	x		The x position of the end point for the line
	 * @param	x		The y position of the end point for the line
	 * @param	strength		The degree of emphasis that should be placed on this segment . If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)
	 * @return		The current motion path instance</haxe_doc>
		</line>
		<bezier public="1" set="method" line="34">
			<f a="x:y:controlX:controlY:?strength">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.MotionPath"/>
			</f>
			<haxe_doc>* Adds a bezier curve to the current motion path
	 * @param	x		The x position of the end point for the curve
	 * @param	y		The y position of the end point for the curve
	 * @param	controlX		The x position of the control point for the curve, which affects the angle and midpoint
	 * @param	controlX		The x position of the control point for the curve, which affects the angle and midpoint
	 * @param	strength		The degree of emphasis that should be placed on this segment. If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)
	 * @return		The current motion path instance</haxe_doc>
		</bezier>
		<_y><c path="com.eclecticdesignstudio.motion.ComponentPath"/></_y>
		<_x><c path="com.eclecticdesignstudio.motion.ComponentPath"/></_x>
		<y public="1" get="get_y" set="null"><c path="com.eclecticdesignstudio.motion.IComponentPath"/></y>
		<x public="1" get="get_x" set="null"><c path="com.eclecticdesignstudio.motion.IComponentPath"/></x>
		<new public="1" set="method" line="17"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.IComponentPath" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/MotionPath.hx" module="com.eclecticdesignstudio.motion.MotionPath" interface="1">
		<calculate public="1" set="method"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<start public="1"><c path="Float"/></start>
		<end public="1" get="get_end" set="null"><c path="Float"/></end>
	</class>
	<class path="com.eclecticdesignstudio.motion.ComponentPath" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/MotionPath.hx" module="com.eclecticdesignstudio.motion.MotionPath">
		<implements path="com.eclecticdesignstudio.motion.IComponentPath"/>
		<get_end set="method" line="151"><f a=""><c path="Float"/></f></get_end>
		<calculate public="1" set="method" line="112"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<addPath public="1" set="method" line="104"><f a="path">
	<c path="com.eclecticdesignstudio.motion.BezierPath"/>
	<e path="Void"/>
</f></addPath>
		<totalStrength><c path="Float"/></totalStrength>
		<paths><c path="Array"><c path="com.eclecticdesignstudio.motion.BezierPath"/></c></paths>
		<end public="1" get="get_end" set="null"><c path="Float"/></end>
		<start public="1"><c path="Float"/></start>
		<new public="1" set="method" line="95"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.BezierPath" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/MotionPath.hx" module="com.eclecticdesignstudio.motion.MotionPath">
		<calculate public="1" set="method" line="201"><f a="start:k">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<strength public="1"><c path="Float"/></strength>
		<end public="1"><c path="Float"/></end>
		<control public="1"><c path="Float"/></control>
		<new public="1" set="method" line="192"><f a="end:control:strength">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.LinearPath" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/MotionPath.hx" module="com.eclecticdesignstudio.motion.MotionPath">
		<extends path="com.eclecticdesignstudio.motion.BezierPath"/>
		<calculate public="1" set="method" line="221" override="1"><f a="start:k">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<new public="1" set="method" line="214"><f a="end:strength">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.FilterActuator" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/FilterActuator.hx">
		<extends path="com.eclecticdesignstudio.motion.actuators.SimpleActuator"/>
		<update set="method" line="92" override="1"><f a="currentTime">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<initialize set="method" line="69" override="1"><f a=""><e path="Void"/></f></initialize>
		<apply public="1" set="method" line="50" override="1"><f a=""><e path="Void"/></f></apply>
		<filterIndex><c path="Int"/></filterIndex>
		<filterClass><c path="Class"><c path="flash.filters.BitmapFilter"/></c></filterClass>
		<filter><c path="flash.filters.BitmapFilter"/></filter>
		<new public="1" set="method" line="20"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.MethodActuator" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/MethodActuator.hx">
		<extends path="com.eclecticdesignstudio.motion.actuators.SimpleActuator"/>
		<update set="method" line="109" override="1"><f a="currentTime">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<initialize set="method" line="81" override="1"><f a=""><e path="Void"/></f></initialize>
		<complete set="method" line="58" override="1"><f a="?sendEvent">
	<e path="Bool"/>
	<e path="Void"/>
</f></complete>
		<apply public="1" set="method" line="43" override="1"><f a=""><e path="Void"/></f></apply>
		<tweenProperties><d/></tweenProperties>
		<currentParameters><c path="Array"><d/></c></currentParameters>
		<new public="1" set="method" line="15"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.MotionPathActuator" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/MotionPathActuator.hx">
		<extends path="com.eclecticdesignstudio.motion.actuators.SimpleActuator"/>
		<update set="method" line="92" override="1"><f a="currentTime">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<initialize set="method" line="47" override="1"><f a=""><e path="Void"/></f></initialize>
		<apply public="1" set="method" line="20" override="1"><f a=""><e path="Void"/></f></apply>
		<new public="1" set="method" line="13"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.PropertyDetails" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/PropertyDetails.hx">
		<target public="1"><d/></target>
		<start public="1"><c path="Float"/></start>
		<propertyName public="1"><c path="String"/></propertyName>
		<isField public="1"><e path="Bool"/></isField>
		<change public="1"><c path="Float"/></change>
		<new public="1" set="method" line="19"><f a="target:propertyName:start:change:?isField">
	<d/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.PropertyPathDetails" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/MotionPathActuator.hx" module="com.eclecticdesignstudio.motion.actuators.MotionPathActuator">
		<extends path="com.eclecticdesignstudio.motion.actuators.PropertyDetails"/>
		<path public="1"><c path="com.eclecticdesignstudio.motion.IComponentPath"/></path>
		<new public="1" set="method" line="245"><f a="target:propertyName:path:?isField">
	<d/>
	<c path="String"/>
	<c path="com.eclecticdesignstudio.motion.IComponentPath"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.TransformActuator" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/actuators/TransformActuator.hx">
		<extends path="com.eclecticdesignstudio.motion.actuators.SimpleActuator"/>
		<update set="method" line="175" override="1"><f a="currentTime">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<initializeSound set="method" line="146"><f a=""><e path="Void"/></f></initializeSound>
		<initializeColor set="method" line="70"><f a=""><e path="Void"/></f></initializeColor>
		<initialize set="method" line="50" override="1"><f a=""><e path="Void"/></f></initialize>
		<apply public="1" set="method" line="31" override="1"><f a=""><e path="Void"/></f></apply>
		<tweenSoundTransform><c path="flash.media.SoundTransform"/></tweenSoundTransform>
		<tweenColorTransform><c path="flash.geom.ColorTransform"/></tweenColorTransform>
		<endSoundTransform><c path="flash.media.SoundTransform"/></endSoundTransform>
		<endColorTransform><c path="flash.geom.ColorTransform"/></endColorTransform>
		<new public="1" set="method" line="24"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.Cubic" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Cubic.hx">
		<easeIn public="1" get="getEaseIn" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeIn>
		<easeInOut public="1" get="getEaseInOut" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeInOut>
		<easeOut public="1" get="getEaseOut" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeOut>
		<getEaseIn set="method" line="19" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></getEaseIn>
		<getEaseInOut set="method" line="26" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></getEaseInOut>
		<getEaseOut set="method" line="33" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></getEaseOut>
		<haxe_doc>* @author Joshua Granick
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.CubicEaseIn" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Cubic.hx" module="com.eclecticdesignstudio.motion.easing.Cubic">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<ease public="1" set="method" line="60"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="53"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<new public="1" set="method" line="46"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.CubicEaseInOut" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Cubic.hx" module="com.eclecticdesignstudio.motion.easing.Cubic">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<ease public="1" set="method" line="87"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="80"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<new public="1" set="method" line="73"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.CubicEaseOut" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Cubic.hx" module="com.eclecticdesignstudio.motion.easing.Cubic">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<ease public="1" set="method" line="114"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="107"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<new public="1" set="method" line="100"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.ExpoEaseIn" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Expo.hx" module="com.eclecticdesignstudio.motion.easing.Expo">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<ease public="1" set="method" line="60"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="53"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<new public="1" set="method" line="46"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.ExpoEaseInOut" params="" file="/usr/lib/haxe/lib/actuate/1,52/com/eclecticdesignstudio/motion/easing/Expo.hx" module="com.eclecticdesignstudio.motion.easing.Expo">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<ease public="1" set="method" line="92"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="80"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<new public="1" set="method" line="73"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<visible public="1"><e path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><c path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><c path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><c path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1">
			<f a=""><e path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<removeChildren public="1">
			<f a="?beginIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1">
			<f a="touchPointID">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<startTouchDrag public="1">
			<f a="touchPointID:?lockCenter:?bounds">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.display.GameDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/GameDisplay.hx">
		<extends path="flash.display.Sprite"/>
		<onExitPart set="method" line="76"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onExitPart>
		<displayPart set="method" line="62"><f a="part">
	<c path="com.knowledgeplayers.grar.structure.part.Part"/>
	<e path="Void"/>
</f></displayPart>
		<launchPart set="method" line="56"><f a="part">
	<c path="com.knowledgeplayers.grar.structure.part.Part"/>
	<e path="Void"/>
</f></launchPart>
		<displayMenu set="method" line="49"><f a=""><e path="Void"/></f></displayMenu>
		<game>
			<c path="com.knowledgeplayers.grar.structure.Game"/>
			<haxe_doc>* The game model</haxe_doc>
		</game>
		<menu>
			<c path="com.knowledgeplayers.grar.display.part.MenuDisplay"/>
			<haxe_doc>* Menu of the game</haxe_doc>
		</menu>
		<currentPart>
			<c path="com.knowledgeplayers.grar.display.part.PartDisplay"/>
			<haxe_doc>* Part currently displayed</haxe_doc>
		</currentPart>
		<new public="1" set="method" line="42">
			<f a="game">
				<c path="com.knowledgeplayers.grar.structure.Game"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	game : the model to display</haxe_doc>
		</new>
		<haxe_doc>* Display of a game</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.ResizeManager" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/ResizeManager.hx">
		<extends path="flash.display.Sprite"/>
		<instance get="getInstance" set="null" static="1">
			<c path="com.knowledgeplayers.grar.display.ResizeManager"/>
			<haxe_doc>* Instance of the manaager</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="41" static="1">
			<f a=""><c path="com.knowledgeplayers.grar.display.ResizeManager"/></f>
			<haxe_doc>* @return the instance of the manager</haxe_doc>
		</getInstance>
		<addDisplayObjects public="1" set="method" line="76">
			<f a="dp:?node">
				<t path="nme.display.DisplayObject"/>
				<c path="haxe.xml.Fast"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a display object to be managed
	 * @param	dp : object to manage
	 * @param	node : fast xml node with infos</haxe_doc>
		</addDisplayObjects>
		<onResize public="1" set="method" line="53">
			<f a="?e">
				<t path="nme.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Listener of resize events
	 * @param	e : the event</haxe_doc>
		</onResize>
		<ratioH><c path="Float"/></ratioH>
		<ratioW><c path="Float"/></ratioW>
		<originH><c path="Int"/></originH>
		<originW><c path="Int"/></originW>
		<replacedObjects><c path="List"><d/></c></replacedObjects>
		<resizedObjects><c path="List"><d/></c></resizedObjects>
		<new set="method" line="28"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Manager of resize events</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.TweenManager" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/TweenManager.hx">
		<fadeIn public="1" set="method" line="20" static="1">
			<f a="display">
				<t path="nme.display.DisplayObject"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Get a fade in effect for the object
	 * @param	display : target of the tween
	 * @return the actuator</haxe_doc>
		</fadeIn>
		<fadeOut public="1" set="method" line="31" static="1">
			<f a="display">
				<t path="nme.display.DisplayObject"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Get a fade out effect for the object
	 * @param	display : target of the tween
	 * @return the actuator</haxe_doc>
		</fadeOut>
		<translate public="1" set="method" line="44" static="1">
			<f a="display:origin:destination">
				<t path="nme.display.DisplayObject"/>
				<t path="nme.geom.Point"/>
				<t path="nme.geom.Point"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Translate the object
	 * @param	display : target of the tween
	 * @param	origin : starting point of the object
	 * @param	destination : ending point of the object
	 * @return the actuator</haxe_doc>
		</translate>
		<translateHorizontaly public="1" set="method" line="58" static="1">
			<f a="display:origin:destination">
				<t path="nme.display.DisplayObject"/>
				<e path="com.knowledgeplayers.grar.display.Direction"/>
				<t path="nme.geom.Point"/>
				<c path="com.eclecticdesignstudio.motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Translate the object horizontaly only
	 * @param	display : target of the tween
	 * @param	origin : starting direction of the object
	 * @param	destination : ending point of the object
	 * @return the actuator</haxe_doc>
		</translateHorizontaly>
		<new set="method" line="73"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Manage the most frequently used tweens</haxe_doc>
	</class>
	<enum path="com.knowledgeplayers.grar.display.Direction" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/TweenManager.hx" module="com.knowledgeplayers.grar.display.TweenManager">
		<RIGHT/>
		<LEFT/>
		<haxe_doc>* Possible direction for tweens</haxe_doc>
	</enum>
	<class path="com.knowledgeplayers.grar.display.activity.ActivityDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/activity/ActivityDisplay.hx">
		<extends path="flash.display.Sprite"/>
		<initDisplayObject set="method" line="51"><f a="display:node">
	<t path="nme.display.DisplayObject"/>
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></initDisplayObject>
		<unLoad set="method" line="40"><f a=""><e path="Void"/></f></unLoad>
		<startActivity public="1" set="method" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Start the activity</haxe_doc>
		</startActivity>
		<setDisplay public="1" set="method" line="33">
			<f a="display">
				<c path="haxe.xml.Fast"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the display with XML infos
	 * @param	display : fast XML node with display infos</haxe_doc>
		</setDisplay>
		<setModel public="1" set="method" line="24">
			<f a="model">
				<c path="com.knowledgeplayers.grar.structure.activity.Activity"/>
				<c path="com.knowledgeplayers.grar.structure.activity.Activity"/>
			</f>
			<haxe_doc>* Setter for the model
	 * @param	model : the model to set
	 * @return the model</haxe_doc>
		</setModel>
		<model public="1" set="setModel">
			<c path="com.knowledgeplayers.grar.structure.activity.Activity"/>
			<haxe_doc>* Model to display</haxe_doc>
		</model>
		<new set="method" line="46"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Abstract display for an activity</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.activity.ActivityManager" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/activity/ActivityManager.hx">
		<instance public="1" get="getInstance" set="null" static="1">
			<c path="com.knowledgeplayers.grar.display.activity.ActivityManager"/>
			<haxe_doc>* Instance</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="23" static="1">
			<f a=""><c path="com.knowledgeplayers.grar.display.activity.ActivityManager"/></f>
			<haxe_doc>* @return the instance</haxe_doc>
		</getInstance>
		<getActivity public="1" set="method" line="36">
			<f a="name">
				<c path="String"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.display.activity.ActivityDisplay"/></t>
			</f>
			<haxe_doc>* Return the requested activity display
	 * @param	name : Name of the activity
	 * @return the display for this activity</haxe_doc>
		</getActivity>
		<activities public="1" set="null">
			<c path="Hash"><c path="com.knowledgeplayers.grar.display.activity.ActivityDisplay"/></c>
			<haxe_doc>* Hash of all the activities displays</haxe_doc>
		</activities>
		<new set="method" line="51"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Manager of the activity, store all the activity display for a game</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.activity.quizz.QuizzDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/activity/quizz/QuizzDisplay.hx">
		<extends path="com.knowledgeplayers.grar.display.activity.ActivityDisplay"/>
		<instance public="1" get="getInstance" set="null" static="1">
			<c path="com.knowledgeplayers.grar.display.activity.quizz.QuizzDisplay"/>
			<haxe_doc>* Instance</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="124" static="1">
			<f a=""><c path="com.knowledgeplayers.grar.display.activity.quizz.QuizzDisplay"/></f>
			<haxe_doc>* @return the instance</haxe_doc>
		</getInstance>
		<setState set="method" line="293"><f a="state">
	<e path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzState"/>
	<e path="Void"/>
</f></setState>
		<updateRound set="method" line="283"><f a=""><e path="Void"/></f></updateRound>
		<setLayout set="method" line="273"><f a="layout">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></setLayout>
		<setIcons set="method" line="258"><f a="display">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></setIcons>
		<onValidation set="method" line="241"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onValidation>
		<updateButtonText set="method" line="227"><f a=""><e path="Void"/></f></updateButtonText>
		<parseContent set="method" line="200"><f a="quizz">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseContent>
		<addDisplayObjects set="method" line="173"><f a=""><e path="Void"/></f></addDisplayObjects>
		<startActivity public="1" set="method" line="163" override="1"><f a=""><e path="Void"/></f></startActivity>
		<setDisplay public="1" set="method" line="158" override="1"><f a="display">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></setDisplay>
		<onModelComplete set="method" line="152"><f a="e">
	<c path="com.knowledgeplayers.grar.event.LocaleEvent"/>
	<e path="Void"/>
</f></onModelComplete>
		<onEndActivity set="method" line="145"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onEndActivity>
		<setModel public="1" set="method" line="132" override="1"><f a="model">
	<c path="com.knowledgeplayers.grar.structure.activity.Activity"/>
	<c path="com.knowledgeplayers.grar.structure.activity.Activity"/>
</f></setModel>
		<content public="1"><c path="haxe.xml.Fast"/></content>
		<resizeD><c path="com.knowledgeplayers.grar.display.ResizeManager"/></resizeD>
		<displayObjects><c path="Hash"><t path="nme.display.DisplayObject"/></c></displayObjects>
		<validateTag><c path="String"/></validateTag>
		<validateContent><c path="String"/></validateContent>
		<quizz><c path="com.knowledgeplayers.grar.structure.activity.quizz.Quizz"/></quizz>
		<groupY public="1">
			<c path="Float"/>
			<haxe_doc>* Y position of the answer group</haxe_doc>
		</groupY>
		<groupX public="1">
			<c path="Float"/>
			<haxe_doc>* X position of the answer group</haxe_doc>
		</groupX>
		<groupYOffset public="1">
			<c path="Float"/>
			<haxe_doc>* Y offset in the answer group</haxe_doc>
		</groupYOffset>
		<groupXOffset public="1">
			<c path="Float"/>
			<haxe_doc>* X offset in the answer group</haxe_doc>
		</groupXOffset>
		<correctionXOffset public="1">
			<c path="Float"/>
			<haxe_doc>* X position of the correction icon</haxe_doc>
		</correctionXOffset>
		<itemXOffset public="1">
			<c path="Float"/>
			<haxe_doc>* X postion of the items in a group</haxe_doc>
		</itemXOffset>
		<correction public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Icon to display near the goods answers</haxe_doc>
		</correction>
		<iconCheckWrong public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Icon to display when an answer is wrong</haxe_doc>
		</iconCheckWrong>
		<iconCheckRight public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Icon to display when an answer is right</haxe_doc>
		</iconCheckRight>
		<iconUncheck public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Icon to display when an answer is unchecked</haxe_doc>
		</iconUncheck>
		<iconCheck public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Icon to display when an answer is checked</haxe_doc>
		</iconCheck>
		<locked public="1">
			<e path="Bool"/>
			<haxe_doc>* Lock state of the quizz. If true, the answers can't be changed</haxe_doc>
		</locked>
		<quizzGroup public="1">
			<c path="com.knowledgeplayers.grar.display.activity.quizz.QuizzGroupDisplay"/>
			<haxe_doc>* Group of answers</haxe_doc>
		</quizzGroup>
		<validationButton public="1">
			<c path="com.knowledgeplayers.grar.display.button.DefaultButton"/>
			<haxe_doc>* Validate button</haxe_doc>
		</validationButton>
		<question public="1">
			<c path="com.knowledgeplayers.grar.display.text.StyledTextField"/>
			<haxe_doc>* Question field</haxe_doc>
		</question>
		<new set="method" line="191"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Display for quizz activity. Since all quizz in a game must look alike,
 * this is a singleton.
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.activity.quizz.QuizzGroupDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/activity/quizz/QuizzGroupDisplay.hx">
		<extends path="flash.display.Sprite"/>
		<unloadItems set="method" line="87"><f a=""><e path="Void"/></f></unloadItems>
		<updateItems set="method" line="72"><f a=""><e path="Void"/></f></updateItems>
		<initDisplay set="method" line="66"><f a=""><e path="Void"/></f></initDisplay>
		<correct public="1" set="method" line="57">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Point out the good answers</haxe_doc>
		</correct>
		<validate public="1" set="method" line="47">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Validate the answers</haxe_doc>
		</validate>
		<setModel public="1" set="method" line="36">
			<f a="model">
				<c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzGroup"/>
				<c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzGroup"/>
			</f>
			<haxe_doc>* Setter of the model
	 * @param	model : Model to set
	 * @return the model</haxe_doc>
		</setModel>
		<items><c path="Array"><c path="com.knowledgeplayers.grar.display.activity.quizz.QuizzItemDisplay"/></c></items>
		<model public="1" set="setModel">
			<c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzGroup"/>
			<haxe_doc>* Model to display</haxe_doc>
		</model>
		<new public="1" set="method" line="23">
			<f a="group">
				<c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzGroup"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	group : Model to display</haxe_doc>
		</new>
		<haxe_doc>* Display for a group of answer in a quizz</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.activity.quizz.QuizzItemDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/activity/quizz/QuizzItemDisplay.hx">
		<extends path="flash.display.Sprite"/>
		<onClick set="method" line="99"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClick>
		<displayCorrection public="1" set="method" line="91">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Display the correction icon if the item is a right answer</haxe_doc>
		</displayCorrection>
		<validate public="1" set="method" line="78">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Change the icon to iconCheckRight if the answer is correct</haxe_doc>
		</validate>
		<model><c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzItem"/></model>
		<textS><c path="com.knowledgeplayers.grar.display.container.ScrollPanel"/></textS>
		<correction public="1">
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Icon to show good answers</haxe_doc>
		</correction>
		<icon public="1">
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Icon for the item</haxe_doc>
		</icon>
		<new public="1" set="method" line="43">
			<f a="item">
				<c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Construcor
	 * @param	item : Model to display</haxe_doc>
		</new>
		<haxe_doc>* Display for quizz propositions
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.button.DefaultButton" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/button/DefaultButton.hx">
		<extends path="flash.display.Sprite"/>
		<onMouseEvent set="method" line="171"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseEvent>
		<removeAllEventsListeners set="method" line="157"><f a="listener">
	<f a="">
		<t path="nme.events.MouseEvent"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></removeAllEventsListeners>
		<init set="method" line="132"><f a=""><e path="Void"/></f></init>
		<onClickUp set="method" line="125"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClickUp>
		<onClickDown set="method" line="118"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClickDown>
		<onOut set="method" line="110"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onOut>
		<onOver set="method" line="102"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onOver>
		<setAllListeners set="method" line="89"><f a="listener">
	<f a="">
		<t path="nme.events.MouseEvent"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setAllListeners>
		<close set="method" line="85"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></close>
		<open set="method" line="83"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></open>
		<onDblClick set="method" line="81"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onDblClick>
		<onClick set="method" line="79"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClick>
		<onMouseOut set="method" line="77"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseOut>
		<onMouseOver set="method" line="75"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseOver>
		<enable public="1" set="method" line="65">
			<f a="activate">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Enable or disable the button
	 * @param	activate : True to activate the button
	 * @return true if the button is now activated</haxe_doc>
		</enable>
		<enabled public="1" set="enable">
			<e path="Bool"/>
			<haxe_doc>* Switch to enable the button</haxe_doc>
		</enabled>
		<layer public="1">
			<c path="aze.display.TileLayer"/>
			<haxe_doc>* Layer of the button</haxe_doc>
		</layer>
		<downState public="1">
			<c path="aze.display.TileSprite"/>
			<haxe_doc>* Sprite containing the downstate</haxe_doc>
		</downState>
		<overState public="1">
			<c path="aze.display.TileSprite"/>
			<haxe_doc>* Sprite containing the overstater</haxe_doc>
		</overState>
		<upState public="1">
			<c path="aze.display.TileSprite"/>
			<haxe_doc>* Sprite containing the upstate</haxe_doc>
		</upState>
		<new public="1" set="method" line="46">
			<f a="tilesheet:tile">
				<c path="aze.display.TilesheetEx"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor. Downstate and overstate are automatically set if their tile are
	 * name upstateName+"_pressed" and upstateName+"_over"
	 * @param	tilesheet : UI Sheet
	 * @param	tile : Tile containing the upstate</haxe_doc>
		</new>
		<haxe_doc>* Custom base button class
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.button.CustomEventButton" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/button/CustomEventButton.hx">
		<extends path="com.knowledgeplayers.grar.display.button.DefaultButton"/>
		<onClick set="method" line="35" override="1"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClick>
		<propagateNativeEvent public="1">
			<e path="Bool"/>
			<haxe_doc>* Control whether or not the native event (CLICK) must be propagated</haxe_doc>
		</propagateNativeEvent>
		<eventType public="1">
			<c path="String"/>
			<haxe_doc>* Type of the event to dispatch</haxe_doc>
		</eventType>
		<new public="1" set="method" line="29">
			<f a="eventName:tilesheet:tile">
				<c path="String"/>
				<c path="aze.display.TilesheetEx"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	eventName : Name of the customed event to dispatch
	 * @param	tilesheet : UI sheet
	 * @param	tile : Tile containing the button</haxe_doc>
		</new>
		<haxe_doc>* Button with a customizable event
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.button.AnimationButton" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/button/AnimationButton.hx">
		<extends path="com.knowledgeplayers.grar.display.button.CustomEventButton"/>
		<startAnimIcon set="method" line="89"><f a=""><e path="Void"/></f></startAnimIcon>
		<endAnimIcon set="method" line="82"><f a=""><e path="Void"/></f></endAnimIcon>
		<animRender set="method" line="77"><f a="?e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></animRender>
		<onOut set="method" line="71" override="1"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onOut>
		<onOver set="method" line="65" override="1"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onOver>
		<addIcon set="method" line="51"><f a=""><e path="Void"/></f></addIcon>
		<arrowIcon public="1">
			<c path="aze.display.TileClip"/>
			<haxe_doc>* Tile for the animation</haxe_doc>
		</arrowIcon>
		<fondIcon public="1">
			<c path="aze.display.TileSprite"/>
			<haxe_doc>* Tile for the background</haxe_doc>
		</fondIcon>
		<iconGroup public="1">
			<c path="aze.display.TileGroup"/>
			<haxe_doc>* TileGroup for the button</haxe_doc>
		</iconGroup>
		<new public="1" set="method" line="36">
			<f a="tilesheet:tile:?eventName">
				<c path="aze.display.TilesheetEx"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	tilesheet : UI sheet
	 * @param	tile : Tile containing the button
	 * @param	eventName : Custom event to dispatch</haxe_doc>
		</new>
		<haxe_doc>* Button with an animation</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.button.TextButton" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/button/TextButton.hx">
		<extends path="com.knowledgeplayers.grar.display.button.CustomEventButton"/>
		<centerText set="method" line="61"><f a=""><e path="Void"/></f></centerText>
		<getText public="1" set="method" line="54">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @return the text of the button</haxe_doc>
		</getText>
		<setText public="1" set="method" line="41">
			<f a="text:?tag">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Setter of the text
	 * @param	text : Text to set
	 * @param	tag : Tag of the text</haxe_doc>
		</setText>
		<textField><c path="com.knowledgeplayers.grar.display.text.StyledTextField"/></textField>
		<new public="1" set="method" line="22">
			<f a="tilesheet:tile:?eventName:?text:?tag">
				<c path="aze.display.TilesheetEx"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	tilesheet : UI tilesheet
	 * @param	tile : Tile containing the button
	 * @param	eventName : Event triggered by the button
	 * @param	text : Text of the button
	 * @param	tag : Tag of the text</haxe_doc>
		</new>
		<haxe_doc>* Button with text</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.container.DynBubble" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/container/DynBubble.hx">
		<instance public="1" get="getInstance" set="null" static="1">
			<c path="com.knowledgeplayers.grar.display.container.DynBubble"/>
			<haxe_doc>* Instance of the DynBubble</haxe_doc>
		</instance>
		<isActive static="1"><e path="Bool"/></isActive>
		<getInstance public="1" set="method" line="27" static="1">
			<f a=""><c path="com.knowledgeplayers.grar.display.container.DynBubble"/></f>
			<haxe_doc>* @return the instance of the bubble</haxe_doc>
		</getInstance>
		<updateTextField set="method" line="67"><f a="textField:message:timeNextLetter:tag:?timeSpace:?timeLine">
	<c path="com.knowledgeplayers.grar.display.text.StyledTextField"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updateTextField>
		<stop public="1" set="method" line="61">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Stop the bubble</haxe_doc>
		</stop>
		<convert public="1" set="method" line="39">
			<f a="textField:?timeNextLetter:?timeSpace:?timeLine">
				<c path="com.knowledgeplayers.grar.display.text.StyledTextField"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 
	 * @param	textField
	 * @param	timeNextLetter
	 * @param	timeSpace
	 * @param	timeLine</haxe_doc>
		</convert>
		<new set="method" line="20"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Container that display text one character at a time
 * @deprecated</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.container.ScrollBar" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/container/ScrollBar.hx">
		<extends path="flash.display.Sprite"/>
		<createBar set="method" line="117"><f a="layer:graphics:width:height">
	<c path="aze.display.TileLayer"/>
	<c path="aze.display.TileGroup"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBar>
		<cursorStop set="method" line="110"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></cursorStop>
		<cursorStart set="method" line="103"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></cursorStart>
		<onScroll set="method" line="97"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onScroll>
		<scrolled public="1" set="dynamic" line="93">
			<f a="destination">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Abstract function to scroll the text
	 * @param	destination : where to scroll</haxe_doc>
		</scrolled>
		<moveCursor public="1" set="method" line="75">
			<f a="delta">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Move the cursor. Can't go out of bound
	 * @param	delta : distance to move the cursor</haxe_doc>
		</moveCursor>
		<maxHeight><c path="Float"/></maxHeight>
		<layer><c path="aze.display.TileLayer"/></layer>
		<ratio><c path="Float"/></ratio>
		<page><c path="Float"/></page>
		<cursorHeight><c path="Float"/></cursorHeight>
		<cursorSprite><t path="nme.display.Sprite"/></cursorSprite>
		<cursor><c path="aze.display.TileLayer"/></cursor>
		<new public="1" set="method" line="35">
			<f a="width:height:ratio:tilesheet:tileBackground:tileCursor">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="aze.display.TilesheetEx"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	width : Width of the scrollbar
	 * @param	height : Height of the scrollbar
	 * @param	ratio : Ratio of the cursor 
	 * @param	tileBackground : Tile containing background image
	 * @param	tileCursor : Tile containing cursor image
	 * 
	 * @see UiFactory</haxe_doc>
		</new>
		<haxe_doc>* Scrollbar for text overflow</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.container.ScrollPanel" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/container/ScrollPanel.hx">
		<extends path="flash.display.Sprite"/>
		<moveCursor set="method" line="104"><f a="delta">
	<c path="Float"/>
	<e path="Void"/>
</f></moveCursor>
		<onWheel set="method" line="87"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onWheel>
		<clear set="method" line="81"><f a=""><e path="Void"/></f></clear>
		<scrollToRatio set="method" line="76"><f a="position">
	<c path="Float"/>
	<e path="Void"/>
</f></scrollToRatio>
		<setContent public="1" set="method" line="48">
			<f a="content">
				<t path="nme.display.Sprite"/>
				<t path="nme.display.Sprite"/>
			</f>
			<haxe_doc>* Set the text to the panel
	 * @param	content : Text to set
	 * @return the text</haxe_doc>
		</setContent>
		<scrollable><e path="Bool"/></scrollable>
		<scrollLock><e path="Bool"/></scrollLock>
		<maskHeight><c path="Float"/></maskHeight>
		<maskWidth><c path="Float"/></maskWidth>
		<scrollBar public="1">
			<c path="com.knowledgeplayers.grar.display.container.ScrollBar"/>
			<haxe_doc>* ScrollBar of the panel. Null if the content is smaller than the panel</haxe_doc>
		</scrollBar>
		<content public="1" set="setContent">
			<t path="nme.display.Sprite"/>
			<haxe_doc>* Text in the panel</haxe_doc>
		</content>
		<new public="1" set="method" line="34">
			<f a="width:height:?scrollLock">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	width : Width of the displayed content
	 * @param	height : Height of the displayed content
	 * @param	scrollLock : Disable scroll. False by default</haxe_doc>
		</new>
		<haxe_doc>* ScrollPanel to manage text overflow, with auto scrollbar</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.element.Character" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/element/Character.hx">
		<extends path="flash.display.Sprite"/>
		<origin public="1">
			<t path="nme.geom.Point"/>
			<haxe_doc>* Starting point of the character</haxe_doc>
		</origin>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Graphic representation of a character of the game</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.part.PartDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/part/PartDisplay.hx">
		<extends path="flash.display.Sprite"/>
		<onLoadComplete set="method" line="283"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onLoadComplete>
		<setText set="method" line="271"><f a="item">
	<c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/>
	<e path="Void"/>
</f></setText>
		<setButtonAction set="method" line="261"><f a="button:action">
	<c path="com.knowledgeplayers.grar.display.button.CustomEventButton"/>
	<c path="String"/>
	<e path="Void"/>
</f></setButtonAction>
		<createCharacter set="method" line="239"><f a="character">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></createCharacter>
		<createText set="method" line="224"><f a="textNode">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></createText>
		<createButton set="method" line="206"><f a="buttonNode">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></createButton>
		<createItem set="method" line="192"><f a="itemNode">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></createItem>
		<createBackground set="method" line="183"><f a="bkgNode">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></createBackground>
		<initDisplayObject set="method" line="162"><f a="display:node:?anime">
	<t path="nme.display.DisplayObject"/>
	<c path="haxe.xml.Fast"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></initDisplayObject>
		<nextItem set="method" line="132"><f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t></f></nextItem>
		<next set="method" line="127"><f a="event">
	<c path="com.knowledgeplayers.grar.event.ButtonActionEvent"/>
	<e path="Void"/>
</f></next>
		<parseContent set="method" line="88"><f a="content">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseContent>
		<onTokenAdded set="method" line="78"><f a="e">
	<c path="com.knowledgeplayers.grar.event.TokenEvent"/>
	<e path="Void"/>
</f></onTokenAdded>
		<unLoad public="1" set="method" line="70">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Unload the display from the scene</haxe_doc>
		</unLoad>
		<resizeD><c path="com.knowledgeplayers.grar.display.ResizeManager"/></resizeD>
		<resiz><c path="String"/></resiz>
		<displayObjects><c path="Hash"><t path="nme.display.DisplayObject"/></c></displayObjects>
		<depth><c path="Int"/></depth>
		<currentSpeaker><c path="com.knowledgeplayers.grar.display.element.Character"/></currentSpeaker>
		<charactersDepth><c path="Hash"><c path="Int"/></c></charactersDepth>
		<characters><c path="Hash"><c path="com.knowledgeplayers.grar.display.element.Character"/></c></characters>
		<text><c path="com.knowledgeplayers.grar.display.container.ScrollPanel"/></text>
		<part public="1">
			<c path="com.knowledgeplayers.grar.structure.part.Part"/>
			<haxe_doc>* Part model to display</haxe_doc>
		</part>
		<new public="1" set="method" line="51">
			<f a="part">
				<c path="com.knowledgeplayers.grar.structure.part.Part"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	part : Part to display</haxe_doc>
		</new>
		<haxe_doc>* Display of a part</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.part.DialogDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/part/DialogDisplay.hx">
		<extends path="com.knowledgeplayers.grar.display.part.PartDisplay"/>
		<parseContent set="method" line="135" override="1"><f a="content">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseContent>
		<onActivityReady set="method" line="130"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onActivityReady>
		<onActivityEnd set="method" line="123"><f a="e">
	<c path="com.knowledgeplayers.grar.event.PartEvent"/>
	<e path="Void"/>
</f></onActivityEnd>
		<launchActivity set="method" line="109"><f a="activity">
	<c path="com.knowledgeplayers.grar.structure.activity.Activity"/>
	<e path="Void"/>
</f></launchActivity>
		<nextItem set="method" line="88" override="1"><f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t></f></nextItem>
		<setButtonAction set="method" line="74" override="1"><f a="button:action">
	<c path="com.knowledgeplayers.grar.display.button.CustomEventButton"/>
	<c path="String"/>
	<e path="Void"/>
</f></setButtonAction>
		<vertical set="method" line="45"><f a="event">
	<c path="com.knowledgeplayers.grar.event.ButtonActionEvent"/>
	<e path="Void"/>
</f></vertical>
		<activityDisplay><c path="com.knowledgeplayers.grar.display.activity.ActivityDisplay"/></activityDisplay>
		<displayedToken><t path="nme.display.Bitmap"/></displayedToken>
		<tokens><c path="Hash"><t path="nme.display.Bitmap"/></c></tokens>
		<verticalButton><c path="com.knowledgeplayers.grar.display.button.CustomEventButton"/></verticalButton>
		<new public="1" set="method" line="36">
			<f a="part">
				<c path="com.knowledgeplayers.grar.structure.part.dialog.DialogPart"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	part : DialogPart to display</haxe_doc>
		</new>
		<haxe_doc>* Display of a dialog</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.part.MenuDisplay" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/part/MenuDisplay.hx">
		<extends path="flash.display.Sprite"/>
		<onPartClick set="method" line="51"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onPartClick>
		<launchPart public="1" set="dynamic" line="47">
			<f a="part">
				<c path="com.knowledgeplayers.grar.structure.part.Part"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Abstract function which launch the given part
	 * @param	part : Part to start</haxe_doc>
		</launchPart>
		<parts><c path="Array"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c></parts>
		<new public="1" set="method" line="22">
			<f a="game">
				<c path="com.knowledgeplayers.grar.structure.Game"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	game : Game moddel linked to the menu</haxe_doc>
		</new>
		<haxe_doc>* Display of a menu</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.part.block.Block" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/part/block/Block.hx">
		<RELATIVE get="inline" set="null" line="10" static="1"><c path="String"/></RELATIVE>
		<ABSOLUTE get="inline" set="null" line="11" static="1"><c path="String"/></ABSOLUTE>
		<RECALC get="inline" set="null" line="12" static="1"><c path="String"/></RECALC>
		<LEFT_BORDER get="inline" set="null" line="14" static="1"><c path="String"/></LEFT_BORDER>
		<RIGHT_BORDER get="inline" set="null" line="15" static="1"><c path="String"/></RIGHT_BORDER>
		<TOP_BORDER get="inline" set="null" line="16" static="1"><c path="String"/></TOP_BORDER>
		<BOTTOM_BORDER get="inline" set="null" line="17" static="1"><c path="String"/></BOTTOM_BORDER>
		<ROUND_UPLEFT get="inline" set="null" line="19" static="1"><c path="String"/></ROUND_UPLEFT>
		<ROUND_UPRIGHT get="inline" set="null" line="20" static="1"><c path="String"/></ROUND_UPRIGHT>
		<ROUND_DOWNLEFT get="inline" set="null" line="21" static="1"><c path="String"/></ROUND_DOWNLEFT>
		<ROUND_DOWNRIGHT get="inline" set="null" line="22" static="1"><c path="String"/></ROUND_DOWNRIGHT>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<getNbSprite public="1" set="method" line="180"><f a=""><c path="Int"/></f></getNbSprite>
		<getNbItem public="1" set="method" line="168"><f a=""><c path="Int"/></f></getNbItem>
		<itemIndex><c path="Int"/></itemIndex>
		<items><c path="Array"><c path="com.knowledgeplayers.grar.display.part.block.Item"/></c></items>
		<rounded public="1"><c path="Array"><c path="String"/></c></rounded>
		<borders public="1"><c path="Hash"><c path="Int"/></c></borders>
		<sprites public="1"><c path="Array"><t path="nme.display.Sprite"/></c></sprites>
		<blocks public="1"><c path="Array"><c path="com.knowledgeplayers.grar.display.part.block.Block"/></c></blocks>
		<animation public="1"><c path="String"/></animation>
		<y public="1"><c path="Int"/></y>
		<x public="1"><c path="Int"/></x>
		<delay public="1"><c path="Int"/></delay>
		<hPosition public="1"><c path="String"/></hPosition>
		<wPosition public="1"><c path="String"/></wPosition>
		<height public="1"><c path="Float"/></height>
		<absolute_height public="1"><c path="Int"/></absolute_height>
		<absolute_width public="1"><c path="Int"/></absolute_width>
		<width public="1"><c path="Float"/></width>
		<bgColor public="1"><c path="Int"/></bgColor>
		<rowsNumber public="1"><c path="Int"/></rowsNumber>
		<colsNumber public="1"><c path="Int"/></colsNumber>
		<visible public="1"><e path="Bool"/></visible>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="49"><f a="?xml:?width:?height">
	<c path="haxe.xml.Fast"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.knowledgeplayers.grar.display.part.block.Item" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/part/block/Item.hx">
		<hasVertivalFlow public="1" set="method" line="22"><f a=""><e path="Bool"/></f></hasVertivalFlow>
		<tag public="1"><c path="String"/></tag>
		<content public="1"><c path="String"/></content>
		<new public="1" set="method" line="10"><f a="?xml:?content:?tag">
	<c path="haxe.xml.Fast"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.utils.RegExp" params="" file="/usr/lib/haxe/std/flash/utils/RegExp.hx" extern="1">
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</test>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</exec>
		<source public="1" set="null"><c path="String"/></source>
		<multiline public="1" set="null"><e path="Bool"/></multiline>
		<lastIndex public="1"><c path="Int"/></lastIndex>
		<ignoreCase public="1" set="null"><e path="Bool"/></ignoreCase>
		<global public="1" set="null"><e path="Bool"/></global>
		<extended public="1" set="null"><e path="Bool"/></extended>
		<dotall public="1" set="null"><e path="Bool"/></dotall>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":native"><e>RegExp</e></m></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="com.knowledgeplayers.grar.display.style.KpTextDownParser" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/style/KpTextDownParser.hx">
		<specialRegEx line="16" static="1"><c path="EReg"/></specialRegEx>
		<parse public="1" set="method" line="23" static="1">
			<f a="text">
				<c path="String"/>
				<t path="nme.display.Sprite"/>
			</f>
			<haxe_doc>* Parse the string for MarkUp
	 * @param	text : text to parse
	 * @return a sprite with well-formed text</haxe_doc>
		</parse>
		<parseLine set="method" line="46" static="1"><f a="line">
	<c path="String"/>
	<t path="nme.display.Sprite"/>
</f></parseLine>
		<concatObjects set="method" line="141" static="1"><f a="container:objLeft:?objRight">
	<t path="nme.display.DisplayObjectContainer"/>
	<t path="nme.display.DisplayObject"/>
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></concatObjects>
		<createTextField set="method" line="164" static="1"><f a="substring:?style">
	<c path="String"/>
	<c path="com.knowledgeplayers.grar.display.style.Style"/>
	<c path="com.knowledgeplayers.grar.display.text.StyledTextField"/>
</f></createTextField>
		<setIcons set="method" line="194" static="1"><f a="substring:style:output">
	<c path="String"/>
	<c path="com.knowledgeplayers.grar.display.style.Style"/>
	<t path="nme.display.Sprite"/>
	<e path="Void"/>
</f></setIcons>
		<setBackground set="method" line="215" static="1"><f a="style:output:?bulletChar">
	<c path="com.knowledgeplayers.grar.display.style.Style"/>
	<t path="nme.display.Sprite"/>
	<c path="String"/>
	<e path="Void"/>
</f></setBackground>
		<new set="method" line="246"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Parser for the KP MarkUp language</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.style.Style" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/style/Style.hx">
		<extends path="Hash"><c path="String"/></extends>
		<getUnderline public="1" set="method" line="87">
			<f a=""><t path="Null"><e path="Bool"/></t></f>
			<haxe_doc>* @return whether or not the style is underline</haxe_doc>
		</getUnderline>
		<getItalic public="1" set="method" line="79">
			<f a=""><t path="Null"><e path="Bool"/></t></f>
			<haxe_doc>* @return whether or not the style is italic</haxe_doc>
		</getItalic>
		<getBold public="1" set="method" line="71">
			<f a=""><t path="Null"><e path="Bool"/></t></f>
			<haxe_doc>* @return whether or not the style is bold</haxe_doc>
		</getBold>
		<getColor public="1" set="method" line="63">
			<f a=""><t path="Null"><c path="Int"/></t></f>
			<haxe_doc>* @return the color of the style</haxe_doc>
		</getColor>
		<getSize public="1" set="method" line="55">
			<f a=""><t path="Null"><c path="Int"/></t></f>
			<haxe_doc>* @return the size of the style</haxe_doc>
		</getSize>
		<getFont public="1" set="method" line="47">
			<f a=""><t path="Null"><t path="nme.text.Font"/></t></f>
			<haxe_doc>* @return the font of the style</haxe_doc>
		</getFont>
		<addRule public="1" set="method" line="39">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a rule to the style
	 * @param	name : Name of the rule
	 * @param	value : Value of the rule;</haxe_doc>
		</addRule>
		<background public="1">
			<t path="nme.display.Bitmap"/>
			<haxe_doc>* Background propertie</haxe_doc>
		</background>
		<iconPosition public="1">
			<c path="String"/>
			<haxe_doc>* Position of the icon</haxe_doc>
		</iconPosition>
		<icon public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* Icon in the style</haxe_doc>
		</icon>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Name of the style</haxe_doc>
		</name>
		<new public="1" set="method" line="12"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Style of a text</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.style.StyleParser" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/style/StyleParser.hx">
		<styles public="1" line="16" static="1">
			<c path="Hash"><c path="com.knowledgeplayers.grar.display.style.Style"/></c>
			<haxe_doc>* Hash of the styles parsed</haxe_doc>
		</styles>
		<instance public="1" get="getInstance" set="null" static="1">
			<c path="com.knowledgeplayers.grar.display.style.StyleParser"/>
			<haxe_doc>* Instance of the parser</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="28" static="1">
			<f a=""><c path="com.knowledgeplayers.grar.display.style.StyleParser"/></f>
			<haxe_doc>* @return the instance of the parser</haxe_doc>
		</getInstance>
		<getStyle public="1" set="method" line="71">
			<f a="name">
				<c path="String"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.display.style.Style"/></t>
			</f>
			<haxe_doc>* Get a style by its name. The style file must have been parsed first!
	 * @param	name : Name of the style
	 * @return the style, or null if it doesn't exist</haxe_doc>
		</getStyle>
		<parse public="1" set="method" line="40">
			<f a="xmlContent">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Parse the style file
	 * @param	xmlContent : content of the style file</haxe_doc>
		</parse>
		<new set="method" line="23"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Parser and manager of the styles</haxe_doc>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><c path="Float"/></thickness>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<textInteractionMode public="1">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textColor public="1"><t path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><c path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><e path="Bool"/></selectable>
		<scrollV public="1"><c path="Int"/></scrollV>
		<scrollH public="1"><c path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<multiline public="1"><e path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxChars public="1"><c path="Int"/></maxChars>
		<length public="1" set="null"><c path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<border public="1"><e path="Bool"/></border>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<background public="1"><e path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.display.text.StyledTextField" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/text/StyledTextField.hx">
		<extends path="flash.text.TextField"/>
		<applyStyle set="method" line="66"><f a="style:?startIndex:?endIndex">
	<c path="com.knowledgeplayers.grar.display.style.Style"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></applyStyle>
		<setPartialStyle public="1" set="method" line="59">
			<f a="style:startIndex:endIndex">
				<c path="com.knowledgeplayers.grar.display.style.Style"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set a style between bounds
	 * @param	style : Style to set
	 * @param	startIndex : First affected char
	 * @param	endIndex : Last affected char</haxe_doc>
		</setPartialStyle>
		<setStyle public="1" set="method" line="44">
			<f a="style">
				<c path="com.knowledgeplayers.grar.display.style.Style"/>
				<c path="com.knowledgeplayers.grar.display.style.Style"/>
			</f>
			<haxe_doc>* Set the style of the text
	 * @param	style : Style to set
	 * @return  the style</haxe_doc>
		</setStyle>
		<style public="1" set="setStyle">
			<c path="com.knowledgeplayers.grar.display.style.Style"/>
			<haxe_doc>* Style of the text</haxe_doc>
		</style>
		<new public="1" set="method" line="24">
			<f a="?style">
				<c path="com.knowledgeplayers.grar.display.style.Style"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	style : Style of the text</haxe_doc>
		</new>
		<haxe_doc>* Textfield with embedded style</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.display.text.UrlField" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/display/text/UrlField.hx">
		<extends path="flash.display.Sprite"/>
		<onClick set="method" line="38"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClick>
		<textField><c path="com.knowledgeplayers.grar.display.text.StyledTextField"/></textField>
		<url public="1">
			<c path="String"/>
			<haxe_doc>* Url targeted by the field</haxe_doc>
		</url>
		<new public="1" set="method" line="26">
			<f a="url:?text">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	url : URL to target
	 * @param	text : text to display instead of the URL</haxe_doc>
		</new>
		<haxe_doc>* Url Filed</haxe_doc>
	</class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.knowledgeplayers.grar.event.ButtonActionEvent" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/event/ButtonActionEvent.hx">
		<extends path="flash.events.Event"/>
		<NEXT public="1" set="null" line="14" static="1">
			<c path="String"/>
			<haxe_doc>* Move to the next item</haxe_doc>
		</NEXT>
		<VERTICAL_FLOW public="1" set="null" line="19" static="1">
			<c path="String"/>
			<haxe_doc>* Start a vertical flow</haxe_doc>
		</VERTICAL_FLOW>
		<new public="1" set="method" line="21"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Event for the buttons
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.event.GameEvent" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/event/GameEvent.hx">
		<extends path="flash.events.Event"/>
		<GAME_OVER public="1" set="null" line="13" static="1">
			<c path="String"/>
			<haxe_doc>* The game is over</haxe_doc>
		</GAME_OVER>
		<new public="1" set="method" line="15"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Events of the game</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.event.LocaleEvent" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/event/LocaleEvent.hx">
		<extends path="flash.events.Event"/>
		<LOCALE_LOADED public="1" set="null" line="13" static="1">
			<c path="String"/>
			<haxe_doc>* The locale is fully loaded</haxe_doc>
		</LOCALE_LOADED>
		<new public="1" set="method" line="15"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Localisation related event</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.event.PartEvent" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/event/PartEvent.hx">
		<extends path="flash.events.Event"/>
		<ENTER_PART public="1" set="null" line="13" static="1">
			<c path="String"/>
			<haxe_doc>* Enter the part</haxe_doc>
		</ENTER_PART>
		<EXIT_PART public="1" set="null" line="18" static="1">
			<c path="String"/>
			<haxe_doc>* Exit the part</haxe_doc>
		</EXIT_PART>
		<PART_LOADED public="1" set="null" line="23" static="1">
			<c path="String"/>
			<haxe_doc>* The part is fully loaded</haxe_doc>
		</PART_LOADED>
		<new public="1" set="method" line="25"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Part related event</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.event.TokenEvent" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/event/TokenEvent.hx">
		<extends path="flash.events.Event"/>
		<ADD public="1" set="null" line="13" static="1">
			<c path="String"/>
			<haxe_doc>* Add token to the inventory</haxe_doc>
		</ADD>
		<ADD_GLOBAL public="1" line="18" static="1">
			<c path="String"/>
			<haxe_doc>* Add token to the global inventory</haxe_doc>
		</ADD_GLOBAL>
		<tokenTarget public="1">
			<c path="String"/>
			<haxe_doc>* Inventory targeted by the token</haxe_doc>
		</tokenTarget>
		<tokenType public="1">
			<c path="String"/>
			<haxe_doc>* Type of the token</haxe_doc>
		</tokenType>
		<tokenId public="1">
			<c path="String"/>
			<haxe_doc>* ID of the token</haxe_doc>
		</tokenId>
		<new public="1" set="method" line="35"><f a="type:?tokenId:?tokenType:?tokenTarget:?bubbles:?cancelable">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Token related event</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.factory.ActivityFactory" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/factory/ActivityFactory.hx">
		<createActivity public="1" set="method" line="25" static="1">
			<f a="activityName:?content">
				<c path="String"/>
				<c path="String"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.activity.Activity"/></t>
			</f>
			<haxe_doc>* Create an activity
	 * @param	activityName : Name of the activity, define the type of the creation
	 * @param	content : Path to a content file for the creation
	 * @return an newly created activity, or null if the given name doesn't correspond to a valid type</haxe_doc>
		</createActivity>
		<createActivityFromXml public="1" set="method" line="41" static="1">
			<f a="xml">
				<c path="haxe.xml.Fast"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.activity.Activity"/></t>
			</f>
			<haxe_doc>* Create an activity from XML infos
	 * @param	xml : fast xml node with structure infos
	 * @return an newly created activity, or null if the given name doesn't correspond to a valid type</haxe_doc>
		</createActivityFromXml>
		<new set="method" line="14"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Factory for activities creation</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.factory.DisplayFactory" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/factory/DisplayFactory.hx">
		<createPartDisplay public="1" set="method" line="28" static="1">
			<f a="part">
				<c path="com.knowledgeplayers.grar.structure.part.Part"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.display.part.PartDisplay"/></t>
			</f>
			<haxe_doc>* Create a display for a part
	 * @param	part : Part to display
	 * @return the corresponding PartDisplay</haxe_doc>
		</createPartDisplay>
		<new set="method" line="19"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Factory to create displays
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.factory.ItemFactory" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/factory/ItemFactory.hx">
		<createItem public="1" set="method" line="27" static="1">
			<f a="itemType:?xml">
				<c path="String"/>
				<c path="haxe.xml.Fast"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t>
			</f>
			<haxe_doc>* Create an item
	 * @param	itemType : Type of the item
	 * @param	xml : Fast xml node with infos
	 * @return an item, or null if the type is not supported</haxe_doc>
		</createItem>
		<createItemFromXml public="1" set="method" line="45" static="1">
			<f a="xml">
				<c path="haxe.xml.Fast"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t>
			</f>
			<haxe_doc>* Create an item from XML infos
	 * @param	xml : Fast xml node with infos
	 * @return an item, or null if the type is not supported</haxe_doc>
		</createItemFromXml>
		<new set="method" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Factory to create dialog items
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.factory.PartFactory" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/factory/PartFactory.hx">
		<createPart public="1" set="method" line="28" static="1">
			<f a="partType">
				<c path="String"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t>
			</f>
			<haxe_doc>* Create a part
	 * @param	partType : Type of the part
	 * @return the part, or null if the type is not supported</haxe_doc>
		</createPart>
		<createPartFromXml public="1" set="method" line="47" static="1">
			<f a="xml">
				<c path="haxe.xml.Fast"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t>
			</f>
			<haxe_doc>* Create a part from XML infos
	 * @param	xml : Fast XML node with info
	 * @return the part, or null if the type is not supported</haxe_doc>
		</createPartFromXml>
		<new set="method" line="18"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Factory to create parts
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.factory.PatternFactory" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/factory/PatternFactory.hx">
		<createPattern public="1" set="method" line="28" static="1">
			<f a="patternType:patternName">
				<c path="String"/>
				<c path="String"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.pattern.Pattern"/></t>
			</f>
			<haxe_doc>* Create a pattern
	 * @param	patternType : Type of the pattern
	 * @param	patternName : Name of the pattern
	 * @return the pattern or null if the type is not supported</haxe_doc>
		</createPattern>
		<createPatternFromXml public="1" set="method" line="47" static="1">
			<f a="xml:patternName">
				<c path="haxe.xml.Fast"/>
				<c path="String"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.pattern.Pattern"/></t>
			</f>
			<haxe_doc>* Create a pattern from XML infos
	 * @param	xml : fast XML node with infos
	 * @param	patternName : Name of the pattern
	 * @return the pattern or null if the type is not supported</haxe_doc>
		</createPatternFromXml>
		<new set="method" line="17"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Factory to create dialog pattern
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.factory.UiFactory" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/factory/UiFactory.hx">
		<tilesheet static="1"><c path="aze.display.TilesheetEx"/></tilesheet>
		<createButton public="1" set="method" line="33" static="1">
			<f a="buttonType:tile:?action">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="com.knowledgeplayers.grar.display.button.DefaultButton"/>
			</f>
			<haxe_doc>* Create a button
	 * @param	buttonType : Type of the button
	 * @param	tile : Tile containing the button icon
	 * @param	action : Event to dispatch when the button is clicked. No effects for DefaultButton type
	 * @return the created button</haxe_doc>
		</createButton>
		<createScrollBar public="1" set="method" line="55" static="1">
			<f a="width:height:ratio:tileBackground:tileCursor">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="String"/>
				<c path="String"/>
				<c path="com.knowledgeplayers.grar.display.container.ScrollBar"/>
			</f>
			<haxe_doc>* Create a scrollbar
	 * @param	width : Width of the scrollbar
	 * @param	height : Height of the scrollbar
	 * @param	ratio : Ratio of the cursor 
	 * @param	tileBackground : Tile containing background image
	 * @param	tileCursor : Tile containing cursor image
	 * @return the fresh new scrollbar</haxe_doc>
		</createScrollBar>
		<createButtonFromXml public="1" set="method" line="65" static="1">
			<f a="xml">
				<c path="haxe.xml.Fast"/>
				<c path="com.knowledgeplayers.grar.display.button.DefaultButton"/>
			</f>
			<haxe_doc>* Create a button from XML infos
	 * @param	xml : fast xml node with infos
	 * @return the button</haxe_doc>
		</createButtonFromXml>
		<setSpriteSheet public="1" set="method" line="74" static="1">
			<f a="pathToXml">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the spritesheet file containing all the UI images
	 * @param	pathToXml : path to the XML file</haxe_doc>
		</setSpriteSheet>
		<new set="method" line="21"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Factory to create UI components</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.localisation.Localisation" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/localisation/Localisation.hx">
		<extends path="flash.events.EventDispatcher"/>
		<onLoadComplete set="method" line="90"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onLoadComplete>
		<parseContent set="method" line="54"><f a="content">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseContent>
		<getItem public="1" set="method" line="48">
			<f a="key">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get the localised text for an item
	 * @param	key : key of the item
	 * @return the localised text</haxe_doc>
		</getItem>
		<setLocaleFile public="1" set="method" line="36">
			<f a="path">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the path to the file for this locale
	 * @param	path : path to the locale folder</haxe_doc>
		</setLocaleFile>
		<tradHash><c path="Hash"><c path="String"/></c></tradHash>
		<name public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Name of the localisation</haxe_doc>
		</name>
		<new public="1" set="method" line="25">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	name : Name of the localisation (aka language)</haxe_doc>
		</new>
		<haxe_doc>* Localisation</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.localisation.Localiser" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/localisation/Localiser.hx">
		<extends path="flash.events.EventDispatcher"/>
		<instance public="1" get="getInstance" set="null" static="1">
			<c path="com.knowledgeplayers.grar.localisation.Localiser"/>
			<haxe_doc>* Instance of the singleton</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="48" static="1">
			<f a=""><c path="com.knowledgeplayers.grar.localisation.Localiser"/></f>
			<haxe_doc>* @return the instance of the singleton</haxe_doc>
		</getInstance>
		<onLocaleComplete set="method" line="104"><f a="e">
	<c path="com.knowledgeplayers.grar.event.LocaleEvent"/>
	<e path="Void"/>
</f></onLocaleComplete>
		<setLocalisationFile set="method" line="96"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></setLocalisationFile>
		<getItemContent public="1" set="method" line="84">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<haxe_doc>* Get the localised text for the specified item
	 * @param	key : key of the item
	 * @return the localised text</haxe_doc>
		</getItemContent>
		<setCurrentLocale public="1" set="method" line="73">
			<f a="locale">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Setter of the current locale
	 * @param	locale : name of the current locale
	 * @return the name of the current locale</haxe_doc>
		</setCurrentLocale>
		<setLayoutFile public="1" set="method" line="61">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Setter of the layout file
	 * @param	path : Path to the file
	 * @return the path</haxe_doc>
		</setLayoutFile>
		<localisation><c path="com.knowledgeplayers.grar.localisation.Localisation"/></localisation>
		<outroId><c path="String"/></outroId>
		<introId><c path="String"/></introId>
		<layoutPath public="1" set="setLayoutFile">
			<c path="String"/>
			<haxe_doc>* Path of the structure file that describes the layout</haxe_doc>
		</layoutPath>
		<localisations public="1" set="null">
			<c path="Hash"><c path="String"/></c>
			<haxe_doc>* Hash of all the localisations registred in the localiser</haxe_doc>
		</localisations>
		<currentLocale public="1" set="setCurrentLocale">
			<c path="String"/>
			<haxe_doc>* Current locale</haxe_doc>
		</currentLocale>
		<new set="method" line="39"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Singleton manager of the localisation</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.structure.Game" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/Game.hx" interface="1">
		<implements path="flash.events.IEventDispatcher"/>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<getLoadingCompletion public="1" set="method"><f a=""><c path="Float"/></f></getLoadingCompletion>
		<initTracking public="1" set="method"><f a="?mode">
	<e path="com.knowledgeplayers.grar.tracking.Mode"/>
	<e path="Void"/>
</f></initTracking>
		<addLanguage public="1" set="method"><f a="value:path:flagIconPath">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addLanguage>
		<getAllParts public="1" set="method"><f a=""><c path="Array"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c></f></getAllParts>
		<addPart public="1" set="method"><f a="partIndex:part">
	<c path="Int"/>
	<c path="com.knowledgeplayers.grar.structure.part.Part"/>
	<e path="Void"/>
</f></addPart>
		<init public="1" set="method"><f a="xml">
	<c path="Xml"/>
	<e path="Void"/>
</f></init>
		<next public="1" set="method"><f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t></f></next>
		<start public="1" set="method"><f a="?partId">
	<c path="Int"/>
	<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t>
</f></start>
		<inventory public="1" set="null"><c path="Array"><c path="String"/></c></inventory>
		<state public="1"><c path="String"/></state>
		<title public="1"><c path="String"/></title>
		<mode public="1"><e path="com.knowledgeplayers.grar.tracking.Mode"/></mode>
	</class>
	<class path="com.knowledgeplayers.grar.structure.KpGame" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/KpGame.hx">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="com.knowledgeplayers.grar.structure.Game"/>
		<onExit set="method" line="274"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onExit>
		<onGlobalTokenAdd set="method" line="269"><f a="e">
	<c path="com.knowledgeplayers.grar.event.TokenEvent"/>
	<e path="Void"/>
</f></onGlobalTokenAdd>
		<onPartComplete set="method" line="264"><f a="event">
	<c path="com.knowledgeplayers.grar.event.PartEvent"/>
	<e path="Void"/>
</f></onPartComplete>
		<onPartLoaded set="method" line="254"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onPartLoaded>
		<onLanguagesComplete set="method" line="248"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onLanguagesComplete>
		<onActivityComplete set="method" line="242"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onActivityComplete>
		<initActivities set="method" line="234"><f a="xml">
	<c path="Xml"/>
	<e path="Void"/>
</f></initActivities>
		<initLangs set="method" line="225"><f a="xml">
	<c path="Xml"/>
	<e path="Void"/>
</f></initLangs>
		<addPartFromXml set="method" line="218"><f a="partIndex:partXml">
	<c path="Int"/>
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></addPartFromXml>
		<checkIntegrity set="method" line="211"><f a=""><e path="Void"/></f></checkIntegrity>
		<getAllParts public="1" set="method" line="199">
			<f a=""><c path="Array"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c></f>
			<haxe_doc>* Return all the parts of the game
	 * @return an array of parts</haxe_doc>
		</getAllParts>
		<getLoadingCompletion public="1" set="method" line="190">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the state of loading of the game
	 * @return a float between 0 (nothing loaded) and 1 (everything's loaded)</haxe_doc>
		</getLoadingCompletion>
		<initTracking public="1" set="method" line="174">
			<f a="?mode">
				<e path="com.knowledgeplayers.grar.tracking.Mode"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Start the tracking
	 * @param	mode : tracking mode (SCORM/AICC)</haxe_doc>
		</initTracking>
		<toString public="1" set="method" line="165" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @return a string-based representation of the game</haxe_doc>
		</toString>
		<addLanguage public="1" set="method" line="156">
			<f a="value:path:flagIconPath">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a language to the game
	 * @param	value : name of the language
	 * @param	path : path to the localisation folder
	 * @param	flagIconPath : path to the flag for this language</haxe_doc>
		</addLanguage>
		<addPart public="1" set="method" line="141">
			<f a="partIndex:part">
				<c path="Int"/>
				<c path="com.knowledgeplayers.grar.structure.part.Part"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a part to the game at partIndex
	 * @param	partIndex : position of the part in the game
	 * @param	part : the part to add</haxe_doc>
		</addPart>
		<next public="1" set="method" line="122">
			<f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t></f>
			<haxe_doc>* Return the next part of the game
	 * @return the next part or null if the game is over</haxe_doc>
		</next>
		<start public="1" set="method" line="105">
			<f a="?partId">
				<c path="Int"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t>
			</f>
			<haxe_doc>* Start the game
	 * @param	partId : the ID of the part to start.
	 * @return 	the part with id partId or null if this part doesn't exist</haxe_doc>
		</start>
		<init public="1" set="method" line="67">
			<f a="xml">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialize the game with a xml structure
	 * @param	xml : the structure</haxe_doc>
		</init>
		<partIndex><c path="Int"/></partIndex>
		<nbPartsLoaded><c path="Int"/></nbPartsLoaded>
		<connection><c path="com.knowledgeplayers.grar.tracking.Connection"/></connection>
		<parts><c path="IntHash"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c></parts>
		<flags><c path="Hash"><c path="String"/></c></flags>
		<stateInfos><c path="com.knowledgeplayers.grar.tracking.StateInfos"/></stateInfos>
		<languages><c path="Hash"><c path="String"/></c></languages>
		<structureXml><c path="haxe.xml.Fast"/></structureXml>
		<inventory public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Global inventory</haxe_doc>
		</inventory>
		<state public="1">
			<c path="String"/>
			<haxe_doc>* State of the game</haxe_doc>
		</state>
		<title public="1">
			<c path="String"/>
			<haxe_doc>* Game title</haxe_doc>
		</title>
		<mode public="1">
			<e path="com.knowledgeplayers.grar.tracking.Mode"/>
			<haxe_doc>* Connection mode</haxe_doc>
		</mode>
		<new public="1" set="method" line="53"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* KP inmplentation of a game</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.structure.activity.Activity" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/activity/Activity.hx">
		<extends path="flash.events.EventDispatcher"/>
		<onLocaleComplete set="method" line="68"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onLocaleComplete>
		<endActivity public="1" set="method" line="60">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Stop the activity, set it to done</haxe_doc>
		</endActivity>
		<startActivity public="1" set="method" line="55">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Start the activity</haxe_doc>
		</startActivity>
		<loadActivity public="1" set="method" line="45">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Load the activity. Must be done before the start</haxe_doc>
		</loadActivity>
		<isEnded>
			<e path="Bool"/>
			<haxe_doc>* True if the activity has been done</haxe_doc>
		</isEnded>
		<previousContent>
			<c path="String"/>
			<haxe_doc>* Path to the previous content file</haxe_doc>
		</previousContent>
		<content public="1">
			<c path="String"/>
			<haxe_doc>* Path to the content file</haxe_doc>
		</content>
		<new set="method" line="35">
			<f a="?content">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	content : Path to the content file</haxe_doc>
		</new>
		<haxe_doc>* Abstract activity
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.structure.activity.quizz.Quizz" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/activity/quizz/Quizz.hx">
		<extends path="com.knowledgeplayers.grar.structure.activity.Activity"/>
		<onLoadComplete set="method" line="107"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onLoadComplete>
		<parseContent set="method" line="92"><f a="content">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseContent>
		<validate public="1" set="method" line="76">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Validate the quizz
	 * @return true if the quizz is over</haxe_doc>
		</validate>
		<getCurrentAnswers public="1" set="method" line="67">
			<f a=""><c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzGroup"/></f>
			<haxe_doc>* @return the answers being proposed</haxe_doc>
		</getCurrentAnswers>
		<getCurrentQuestion public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @return the question being asked</haxe_doc>
		</getCurrentQuestion>
		<startActivity public="1" set="method" line="51" override="1"><f a=""><e path="Void"/></f></startActivity>
		<roundIndex><c path="Int"/></roundIndex>
		<state public="1">
			<e path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzState"/>
			<haxe_doc>* State of correction of the quizz</haxe_doc>
		</state>
		<questions public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Questions for each rounds</haxe_doc>
		</questions>
		<answers public="1">
			<c path="Array"><c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzGroup"/></c>
			<haxe_doc>* Group of answers for each rounds</haxe_doc>
		</answers>
		<new public="1" set="method" line="39">
			<f a="?content">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	content : Path to the content file</haxe_doc>
		</new>
		<haxe_doc>* Structure of the quizz activity
 * @author jbrichardet</haxe_doc>
	</class>
	<enum path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzState" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/activity/quizz/Quizz.hx" module="com.knowledgeplayers.grar.structure.activity.quizz.Quizz">
		<VALIDATED/>
		<EMPTY/>
		<CORRECTED/>
		<haxe_doc>* Possible state of the quizz</haxe_doc>
	</enum>
	<class path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzGroup" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/activity/quizz/QuizzGroup.hx">
		<addXmlItem public="1" set="method" line="33">
			<f a="item">
				<c path="haxe.xml.Fast"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add an XML-described item to the group
	 * @param	item : fast XML node with the item infos</haxe_doc>
		</addXmlItem>
		<addItem public="1" set="method" line="24">
			<f a="item">
				<c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add an item to the group
	 * @param	item : Item to add</haxe_doc>
		</addItem>
		<items public="1" set="null">
			<c path="List"><c path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzItem"/></c>
			<haxe_doc>* List of items in this group</haxe_doc>
		</items>
		<new public="1" set="method" line="15"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Structure for the answer group of the quizz
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.structure.activity.quizz.QuizzItem" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/activity/quizz/QuizzItem.hx">
		<toString public="1" set="method" line="46">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @return a string-based representation of the item</haxe_doc>
		</toString>
		<content public="1">
			<c path="String"/>
			<haxe_doc>* Text of the item</haxe_doc>
		</content>
		<isAnswer public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>* True if the item is the answer to the question</haxe_doc>
		</isAnswer>
		<isChecked public="1">
			<e path="Bool"/>
			<haxe_doc>* True if the item is checked</haxe_doc>
		</isChecked>
		<new public="1" set="method" line="36">
			<f a="content:?isAnswer:?isChecked">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	content : Text of the item
	 * @param	isAnswer : True if the item is the answer. False by default
	 * @param	isChecked : True if the item is checked. False by default</haxe_doc>
		</new>
		<haxe_doc>* Model for quizz propositions
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.Part" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/Part.hx" interface="1">
		<implements path="flash.events.IEventDispatcher"/>
		<isDialog public="1" set="method"><f a=""><e path="Bool"/></f></isDialog>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<activitiesCount public="1" set="method"><f a=""><c path="Int"/></f></activitiesCount>
		<partsCount public="1" set="method"><f a=""><c path="Int"/></f></partsCount>
		<hasParts public="1" set="method"><f a=""><e path="Bool"/></f></hasParts>
		<getAllParts public="1" set="method"><f a=""><c path="Array"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c></f></getAllParts>
		<getNextItem public="1" set="method"><f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t></f></getNextItem>
		<next public="1" set="method"><f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t></f></next>
		<start public="1" set="method"><f a="?forced">
	<e path="Bool"/>
	<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t>
</f></start>
		<init public="1" set="method"><f a="xml:?filePath">
	<c path="haxe.xml.Fast"/>
	<c path="String"/>
	<e path="Void"/>
</f></init>
		<soundLoop public="1"><t path="nme.media.Sound"/></soundLoop>
		<inventory public="1" set="null"><c path="Array"><c path="String"/></c></inventory>
		<items public="1" set="null"><c path="Array"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></c></items>
		<parts public="1" set="null"><c path="IntHash"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c></parts>
		<activities public="1" set="null"><c path="IntHash"><c path="com.knowledgeplayers.grar.structure.activity.Activity"/></c></activities>
		<options public="1" set="null"><c path="Hash"><c path="String"/></c></options>
		<isDone public="1"><e path="Bool"/></isDone>
		<display public="1"><c path="String"/></display>
		<file public="1" set="null"><c path="String"/></file>
		<id public="1"><c path="Int"/></id>
		<name public="1"><c path="String"/></name>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.StructurePart" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/StructurePart.hx">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="com.knowledgeplayers.grar.structure.part.Part"/>
		<exitPart set="method" line="321"><f a=""><e path="Void"/></f></exitPart>
		<onAddToken set="method" line="309"><f a="e">
	<c path="com.knowledgeplayers.grar.event.TokenEvent"/>
	<e path="Void"/>
</f></onAddToken>
		<fireLoaded set="method" line="304"><f a=""><e path="Void"/></f></fireLoaded>
		<onPartLoaded set="method" line="296"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onPartLoaded>
		<enterPart set="method" line="289"><f a=""><e path="Void"/></f></enterPart>
		<onLoadComplete set="method" line="284"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onLoadComplete>
		<parseXml set="method" line="244"><f a="xml">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></parseXml>
		<parseContent set="method" line="235"><f a="content">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseContent>
		<isDialog public="1" set="method" line="228">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Tell if this part is a dialog
	 * @return true if this part is a dialog</haxe_doc>
		</isDialog>
		<toString public="1" set="method" line="216" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @return a string-based representation of the part</haxe_doc>
		</toString>
		<getAllParts public="1" set="method" line="200">
			<f a=""><c path="Array"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c></f>
			<haxe_doc>* @return all the sub-part of this part</haxe_doc>
		</getAllParts>
		<activitiesCount public="1" set="method" line="192">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* @return the number of activities in the part</haxe_doc>
		</activitiesCount>
		<partsCount public="1" set="method" line="184">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* @return the number of sub-part</haxe_doc>
		</partsCount>
		<hasParts public="1" set="method" line="176">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Tell if this part has sub-part or not
	 * @return true if it has sub-part</haxe_doc>
		</hasParts>
		<next public="1" set="method" line="152">
			<f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t></f>
			<haxe_doc>* @return the next undone part</haxe_doc>
		</next>
		<getNextItem public="1" set="method" line="137">
			<f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t></f>
			<haxe_doc>* @return the next item in the part or null if the part is over</haxe_doc>
		</getNextItem>
		<start public="1" set="method" line="124">
			<f a="?forced">
				<e path="Bool"/>
				<t path="Null"><c path="com.knowledgeplayers.grar.structure.part.Part"/></t>
			</f>
			<haxe_doc>* Start the part if it hasn't been done
	 * @param	forced : true to start the part even if it has already been done
	 * @return this part, or null if it can't be start</haxe_doc>
		</start>
		<init public="1" set="method" line="101">
			<f a="xml:?filePath">
				<c path="haxe.xml.Fast"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialise the part with an XML node
	 * @param	xml : fast node with structure infos
	 * @param	filePath : path to an XML structure file (set the file variable)</haxe_doc>
		</init>
		<soundLoopChannel><t path="nme.media.SoundChannel"/></soundLoopChannel>
		<partIndex><c path="Int"/></partIndex>
		<itemIndex><c path="Int"/></itemIndex>
		<nbSubPartTotal><c path="Int"/></nbSubPartTotal>
		<nbSubPartLoaded><c path="Int"/></nbSubPartLoaded>
		<items public="1" set="null">
			<c path="Array"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></c>
			<haxe_doc>* Text items of the part</haxe_doc>
		</items>
		<soundLoop public="1">
			<t path="nme.media.Sound"/>
			<haxe_doc>* Sound playing during the part</haxe_doc>
		</soundLoop>
		<inventory public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Inventory specific to the part</haxe_doc>
		</inventory>
		<parts public="1" set="null">
			<c path="IntHash"><c path="com.knowledgeplayers.grar.structure.part.Part"/></c>
			<haxe_doc>* Hash of the sub-parts</haxe_doc>
		</parts>
		<activities public="1" set="null">
			<c path="IntHash"><c path="com.knowledgeplayers.grar.structure.activity.Activity"/></c>
			<haxe_doc>* Array of all the activities in the part</haxe_doc>
		</activities>
		<options public="1" set="null">
			<c path="Hash"><c path="String"/></c>
			<haxe_doc>* Misc options for the part
	 * @todo Do something with the options</haxe_doc>
		</options>
		<isDone public="1">
			<e path="Bool"/>
			<haxe_doc>* True if the part is done</haxe_doc>
		</isDone>
		<display public="1">
			<c path="String"/>
			<haxe_doc>* Path to the XML display file</haxe_doc>
		</display>
		<file public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Path to the XML structure file</haxe_doc>
		</file>
		<id public="1">
			<c path="Int"/>
			<haxe_doc>* ID of the part</haxe_doc>
		</id>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Name of the part</haxe_doc>
		</name>
		<new public="1" set="method" line="85"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.DialogPart" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/DialogPart.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.StructurePart"/>
		<parseContent set="method" line="79" override="1"><f a="content">
	<c path="Xml"/>
	<e path="Void"/>
</f></parseContent>
		<getNextVerticalIndex public="1" set="method" line="61">
			<f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.ChoiceItem"/></t></f>
			<haxe_doc>* @return the next item in a vertical flow, or null if the flow reach its end</haxe_doc>
		</getNextVerticalIndex>
		<isDialog public="1" set="method" line="52" override="1"><f a=""><e path="Bool"/></f></isDialog>
		<getNextItem public="1" set="method" line="35" override="1"><f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t></f></getNextItem>
		<patterns public="1">
			<c path="Array"><c path="com.knowledgeplayers.grar.structure.part.dialog.pattern.Pattern"/></c>
			<haxe_doc>* Array of the patterns composing the dialog</haxe_doc>
		</patterns>
		<new public="1" set="method" line="28"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.Intro" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/Intro.hx">
		<introText public="1"><c path="String"/></introText>
		<characterCard public="1"><c path="Hash"><c path="String"/></c></characterCard>
		<new public="1" set="method" line="12"><f a="?introText:?characterCard">
	<c path="String"/>
	<c path="Hash"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Introduction to the dialog
 * @author jbrichardet</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionActivity" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/conclusion/ConclusionActivity.hx">
		<getType public="1" set="method" line="15"><f a=""><e path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionType"/></f></getType>
		<finishWithFetch public="1" set="method" line="10"><f a=""><e path="Bool"/></f></finishWithFetch>
		<new set="method" line="5"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.Check" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/conclusion/Check.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionActivity"/>
		<new public="1" set="method" line="5"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionType" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/conclusion/ConclusionActivity.hx" module="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionActivity">
		<SKETCH/>
		<SHAKE/>
		<FETCH/>
		<CHECK/>
	</enum>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.Fetch" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/conclusion/Fetch.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionActivity"/>
		<getType public="1" set="method" line="21" override="1"><f a=""><e path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionType"/></f></getType>
		<finishWithFetch public="1" set="method" line="16" override="1"><f a=""><e path="Bool"/></f></finishWithFetch>
		<content public="1"><c path="String"/></content>
		<new public="1" set="method" line="9"><f a="content">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.Shake" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/conclusion/Shake.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionActivity"/>
		<new public="1" set="method" line="5"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.Sketch" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/conclusion/Sketch.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.conclusion.ConclusionActivity"/>
		<finishWithFetch public="1" set="method" line="14" override="1"><f a=""><e path="Bool"/></f></finishWithFetch>
		<animation><t path="nme.display.Sprite"/></animation>
		<new public="1" set="method" line="9"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.item.Item" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/item/Item.hx">
		<hasActivity public="1" set="method" line="53">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* @return true if the item starts an activity</haxe_doc>
		</hasActivity>
		<hasVerticalFlow public="1" set="method" line="45">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* @return true if the item starts a vertical flow</haxe_doc>
		</hasVerticalFlow>
		<direction public="1">
			<c path="String"/>
			<haxe_doc>* Position of the author</haxe_doc>
		</direction>
		<author public="1">
			<c path="String"/>
			<haxe_doc>* Character who says this text</haxe_doc>
		</author>
		<content public="1">
			<c path="String"/>
			<haxe_doc>* Text of the item</haxe_doc>
		</content>
		<new public="1" set="method" line="28">
			<f a="?xml:?content">
				<c path="haxe.xml.Fast"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	xml : fast xml node with structure info
	 * @param	content : text of the item</haxe_doc>
		</new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.item.ChoiceItem" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/item/ChoiceItem.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/>
		<hasVerticalFlow public="1" set="method" line="41" override="1"><f a=""><e path="Bool"/></f></hasVerticalFlow>
		<hasToken public="1" set="method" line="36">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* @return true if the item has a token</haxe_doc>
		</hasToken>
		<tokenType public="1"><c path="String"/></tokenType>
		<target public="1"><c path="String"/></target>
		<tokenId public="1"><c path="String"/></tokenId>
		<new public="1" set="method" line="18">
			<f a="?xml:?tokenId:?target:?tokenType">
				<c path="haxe.xml.Fast"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	xml : fast xml node with structure infos
	 * @param	tokenId : ID of the token
	 * @param	target : Inventory to store the token (activity/global)
	 * @param	tokenType : type of the token (info/physic)</haxe_doc>
		</new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.item.RemarkableEvent" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/item/RemarkableEvent.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/>
		<hasActivity public="1" set="method" line="25" override="1"><f a=""><e path="Bool"/></f></hasActivity>
		<activity public="1">
			<c path="com.knowledgeplayers.grar.structure.activity.Activity"/>
			<haxe_doc>* Activity to start when this item is reached</haxe_doc>
		</activity>
		<new public="1" set="method" line="19">
			<f a="?xml">
				<c path="haxe.xml.Fast"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	xml : fast xml node with structure infos</haxe_doc>
		</new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.pattern.Pattern" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/pattern/Pattern.hx">
		<getNextItem public="1" set="method" line="42">
			<f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></t></f>
			<haxe_doc>* @return the next item in the pattern, or null if the pattern reachs its end</haxe_doc>
		</getNextItem>
		<init public="1" set="method" line="31">
			<f a="xml">
				<c path="haxe.xml.Fast"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Init the pattern with an XML node
	 * @param	xml : fast xml node with structure infos</haxe_doc>
		</init>
		<itemIndex><c path="Int"/></itemIndex>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Name of the pattern</haxe_doc>
		</name>
		<patternContent public="1">
			<c path="Array"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.Item"/></c>
			<haxe_doc>* Array of item composing the pattern</haxe_doc>
		</patternContent>
		<new public="1" set="method" line="21"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.pattern.ActivityPattern" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/pattern/ActivityPattern.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.pattern.Pattern"/>
		<init public="1" set="method" line="22" override="1"><f a="xml">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></init>
		<event public="1">
			<c path="com.knowledgeplayers.grar.structure.part.dialog.item.RemarkableEvent"/>
			<haxe_doc>* Item that will triger an activity</haxe_doc>
		</event>
		<new public="1" set="method" line="17"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.knowledgeplayers.grar.structure.part.dialog.pattern.CollectPattern" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/structure/part/dialog/pattern/CollectPattern.hx">
		<extends path="com.knowledgeplayers.grar.structure.part.dialog.pattern.Pattern"/>
		<progressVertically public="1" set="method" line="44">
			<f a=""><t path="Null"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.ChoiceItem"/></t></f>
			<haxe_doc>* @return the next item in the vertical flow, or null if the flow reachs its end</haxe_doc>
		</progressVertically>
		<init public="1" set="method" line="24" override="1"><f a="xml">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></init>
		<verticalIndex><c path="Int"/></verticalIndex>
		<firstChoiceItem><e path="Bool"/></firstChoiceItem>
		<verticalFlow public="1">
			<c path="Array"><c path="com.knowledgeplayers.grar.structure.part.dialog.item.ChoiceItem"/></c>
			<haxe_doc>* Vertical flow of the pattern</haxe_doc>
		</verticalFlow>
		<new public="1" set="method" line="18"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.knowledgeplayers.grar.tracking.ITracking" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/ITracking.hx" interface="1">
		<implements path="flash.events.IEventDispatcher"/>
		<clearDatas public="1" set="method"><f a=""><e path="Void"/></f></clearDatas>
		<setSuspend public="1" set="method"><f a="suspention">
	<c path="String"/>
	<e path="Void"/>
</f></setSuspend>
		<getSuspend public="1" set="method"><f a=""><c path="String"/></f></getSuspend>
		<getMasteryScore public="1" set="method"><f a=""><c path="Int"/></f></getMasteryScore>
		<exitAU public="1" set="method"><f a=""><e path="Void"/></f></exitAU>
		<putparam public="1" set="method"><f a=""><e path="Void"/></f></putparam>
		<setScore public="1" set="method"><f a="score">
	<c path="Int"/>
	<e path="Void"/>
</f></setScore>
		<getScore public="1" set="method"><f a=""><c path="Int"/></f></getScore>
		<setStatus public="1" set="method"><f a="status">
	<e path="Bool"/>
	<e path="Void"/>
</f></setStatus>
		<getStatus public="1" set="method"><f a=""><c path="String"/></f></getStatus>
		<setLocation public="1" set="method"><f a="location">
	<c path="String"/>
	<e path="Void"/>
</f></setLocation>
		<getLocation public="1" set="method"><f a=""><c path="String"/></f></getLocation>
		<init public="1" set="method"><f a="?isNote:?activation">
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></init>
		<activation public="1" set="method"><f a="activation">
	<c path="String"/>
	<e path="Void"/>
</f></activation>
	</class>
	<class path="com.knowledgeplayers.grar.tracking.Tracking" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/Tracking.hx">
		<implements path="com.knowledgeplayers.grar.tracking.ITracking"/>
		<clearDatas public="1" set="method" line="71"><f a=""><e path="Void"/></f></clearDatas>
		<setSuspend public="1" set="method" line="70"><f a="suspention">
	<c path="String"/>
	<e path="Void"/>
</f></setSuspend>
		<getSuspend public="1" set="method" line="69"><f a=""><c path="String"/></f></getSuspend>
		<getMasteryScore public="1" set="method" line="68"><f a=""><c path="Int"/></f></getMasteryScore>
		<exitAU public="1" set="method" line="67"><f a=""><e path="Void"/></f></exitAU>
		<putparam public="1" set="method" line="66"><f a=""><e path="Void"/></f></putparam>
		<setScore public="1" set="method" line="65"><f a="score">
	<c path="Int"/>
	<e path="Void"/>
</f></setScore>
		<setStatus public="1" set="method" line="64"><f a="status">
	<e path="Bool"/>
	<e path="Void"/>
</f></setStatus>
		<getStatus public="1" set="method" line="63"><f a=""><c path="String"/></f></getStatus>
		<setLocation public="1" set="method" line="62"><f a="location">
	<c path="String"/>
	<e path="Void"/>
</f></setLocation>
		<getLocation public="1" set="method" line="61"><f a=""><c path="String"/></f></getLocation>
		<init public="1" set="method" line="60"><f a="?isNote:?activation">
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></init>
		<activation public="1" set="method" line="59"><f a="activation">
	<c path="String"/>
	<e path="Void"/>
</f></activation>
		<getScore public="1" set="method" line="51"><f a=""><c path="Int"/></f></getScore>
		<removeEventListener public="1" set="method" line="46"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method" line="41"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method" line="36"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method" line="31"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<willTrigger public="1" set="method" line="26"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method" line="22"><f a=""><c path="String"/></f></toString>
		<event><t path="nme.events.EventDispatcher"/></event>
		<suivi public="1"><c path="String"/></suivi>
		<masteryScore public="1"><c path="Int"/></masteryScore>
		<score public="1"><c path="String"/></score>
		<lessonStatus public="1"><c path="String"/></lessonStatus>
		<studentName public="1"><c path="String"/></studentName>
		<studentId public="1"><c path="String"/></studentId>
		<new set="method" line="18"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.tracking.AiccTracking" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/AiccTracking.hx">
		<extends path="com.knowledgeplayers.grar.tracking.Tracking"/>
		<exitAU public="1" set="method" line="306" override="1"><f a=""><e path="Void"/></f></exitAU>
		<putParamError public="1" set="method" line="301"><f a="e">
	<t path="nme.events.IOErrorEvent"/>
	<e path="Void"/>
</f></putParamError>
		<putParamSuccessful public="1" set="method" line="295"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></putParamSuccessful>
		<putparam public="1" set="method" line="261" override="1"><f a=""><e path="Void"/></f></putparam>
		<returnFormatedTime public="1" set="method" line="239"><f a=""><c path="String"/></f></returnFormatedTime>
		<getMasteryScore public="1" set="method" line="234" override="1"><f a=""><c path="Int"/></f></getMasteryScore>
		<setScore public="1" set="method" line="222" override="1"><f a="score">
	<c path="Int"/>
	<e path="Void"/>
</f></setScore>
		<getSuspend public="1" set="method" line="216" override="1"><f a=""><c path="String"/></f></getSuspend>
		<setSuspend public="1" set="method" line="211" override="1"><f a="suspention">
	<c path="String"/>
	<e path="Void"/>
</f></setSuspend>
		<setStatus public="1" set="method" line="186" override="1"><f a="status">
	<e path="Bool"/>
	<e path="Void"/>
</f></setStatus>
		<getStatus public="1" set="method" line="181" override="1"><f a=""><c path="String"/></f></getStatus>
		<setLocation public="1" set="method" line="175" override="1"><f a="location">
	<c path="String"/>
	<e path="Void"/>
</f></setLocation>
		<getLocation public="1" set="method" line="170" override="1"><f a=""><c path="String"/></f></getLocation>
		<loadDatas public="1" set="method" line="128"><f a="datas:isNote">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></loadDatas>
		<getParamError public="1" set="method" line="122"><f a="e">
	<t path="nme.events.IOErrorEvent"/>
	<e path="Void"/>
</f></getParamError>
		<getParamSuccessful public="1" set="method" line="115"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></getParamSuccessful>
		<init public="1" set="method" line="60" override="1"><f a="?isNote:?activation">
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></init>
		<activation public="1" set="method" line="46" override="1"><f a="activation">
	<c path="String"/>
	<e path="Void"/>
</f></activation>
		<note public="1"><e path="Bool"/></note>
		<scriptVars public="1"><t path="nme.net.URLVariables"/></scriptVars>
		<scriptLoader public="1"><t path="nme.net.URLLoader"/></scriptLoader>
		<scriptRequest public="1"><t path="nme.net.URLRequest"/></scriptRequest>
		<timer public="1"><t path="nme.utils.Timer"/></timer>
		<startTime public="1"><c path="Int"/></startTime>
		<isActive public="1"><e path="Bool"/></isActive>
		<isNote public="1"><e path="Bool"/></isNote>
		<lesson_location public="1"><c path="String"/></lesson_location>
		<_aicc_url public="1"><c path="String"/></_aicc_url>
		<_aicc_sid public="1"><c path="String"/></_aicc_sid>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.tracking.AutoTracking" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/AutoTracking.hx">
		<extends path="com.knowledgeplayers.grar.tracking.Tracking"/>
		<onFlushStatus set="method" line="185"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFlushStatus>
		<clearDatas public="1" set="method" line="180" override="1"><f a=""><e path="Void"/></f></clearDatas>
		<getSuspend public="1" set="method" line="174" override="1"><f a=""><c path="String"/></f></getSuspend>
		<setSuspend public="1" set="method" line="169" override="1"><f a="suspention">
	<c path="String"/>
	<e path="Void"/>
</f></setSuspend>
		<getMasteryScore public="1" set="method" line="164" override="1"><f a=""><c path="Int"/></f></getMasteryScore>
		<load public="1" set="method" line="155"><f a=""><e path="Void"/></f></load>
		<save public="1" set="method" line="130"><f a=""><e path="Void"/></f></save>
		<exitAU public="1" set="method" line="125" override="1"><f a=""><e path="Void"/></f></exitAU>
		<putparam public="1" set="method" line="116" override="1"><f a=""><e path="Void"/></f></putparam>
		<setScore public="1" set="method" line="100" override="1"><f a="score">
	<c path="Int"/>
	<e path="Void"/>
</f></setScore>
		<setStatus public="1" set="method" line="76" override="1"><f a="status">
	<e path="Bool"/>
	<e path="Void"/>
</f></setStatus>
		<getStatus public="1" set="method" line="71" override="1"><f a=""><c path="String"/></f></getStatus>
		<setLocation public="1" set="method" line="63" override="1"><f a="location">
	<c path="String"/>
	<e path="Void"/>
</f></setLocation>
		<getLocation public="1" set="method" line="58" override="1"><f a=""><c path="String"/></f></getLocation>
		<init public="1" set="method" line="43" override="1"><f a="?isNote:?activation">
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></init>
		<activation public="1" set="method" line="28" override="1"><f a="activation">
	<c path="String"/>
	<e path="Void"/>
</f></activation>
		<mySo><t path="nme.net.SharedObject"/></mySo>
		<isActive public="1"><e path="Bool"/></isActive>
		<isNote public="1"><e path="Bool"/></isNote>
		<lesson_location public="1"><c path="String"/></lesson_location>
		<new public="1" set="method" line="18"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.tracking.Connection" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/Connection.hx">
		<extends path="flash.events.EventDispatcher"/>
		<revertTracking public="1" set="method" line="39"><f a=""><c path="com.knowledgeplayers.grar.tracking.StateInfos"/></f></revertTracking>
		<computeTracking public="1" set="method" line="33"><f a="stateInfos">
	<c path="com.knowledgeplayers.grar.tracking.StateInfos"/>
	<e path="Void"/>
</f></computeTracking>
		<initConnection public="1" set="method" line="17"><f a="mode:?isNote">
	<e path="com.knowledgeplayers.grar.tracking.Mode"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></initConnection>
		<tracking public="1" set="null"><c path="com.knowledgeplayers.grar.tracking.Tracking"/></tracking>
		<new public="1" set="method" line="12"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="com.knowledgeplayers.grar.tracking.Mode" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/Connection.hx" module="com.knowledgeplayers.grar.tracking.Connection">
		<SCORM2004/>
		<SCORM/>
		<AUTO/>
		<AICC/>
	</enum>
	<class path="com.knowledgeplayers.grar.tracking.Scorm" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/Scorm.hx">
		<__stringToBool set="method" line="243"><f a="value">
	<c path="String"/>
	<e path="Bool"/>
</f></__stringToBool>
		<__displayDebugInfo set="method" line="232"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></__displayDebugInfo>
		<__getDiagnosticInfo set="method" line="225"><f a="errorCode">
	<c path="Int"/>
	<c path="String"/>
</f></__getDiagnosticInfo>
		<__getDebugInfo set="method" line="218"><f a="errorCode">
	<c path="Int"/>
	<c path="String"/>
</f></__getDebugInfo>
		<__getDebugCode set="method" line="211"><f a=""><c path="Int"/></f></__getDebugCode>
		<__save set="method" line="189"><f a=""><e path="Bool"/></f></__save>
		<__set set="method" line="168"><f a="parameter:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></__set>
		<__get set="method" line="143"><f a="parameter">
	<c path="String"/>
	<c path="String"/>
</f></__get>
		<__disconnect set="method" line="121"><f a=""><e path="Bool"/></f></__disconnect>
		<__connect set="method" line="86"><f a=""><e path="Bool"/></f></__connect>
		<save public="1" set="method" line="77"><f a=""><e path="Bool"/></f></save>
		<set public="1" set="method" line="72"><f a="parameter:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></set>
		<get public="1" set="method" line="66"><f a="param">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<disconnect public="1" set="method" line="62"><f a=""><e path="Bool"/></f></disconnect>
		<connect public="1" set="method" line="57"><f a=""><e path="Bool"/></f></connect>
		<getDebugMode public="1" set="method" line="53"><f a=""><e path="Bool"/></f></getDebugMode>
		<setDebugMode public="1" set="method" line="49"><f a="status">
	<e path="Bool"/>
	<e path="Void"/>
</f></setDebugMode>
		<__debugActive><e path="Bool"/></__debugActive>
		<__connectionActive><e path="Bool"/></__connectionActive>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.tracking.ScormTracking" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/ScormTracking.hx">
		<extends path="com.knowledgeplayers.grar.tracking.Tracking"/>
		<clearDatas public="1" set="method" line="289" override="1"><f a=""><e path="Void"/></f></clearDatas>
		<exitAU public="1" set="method" line="284" override="1"><f a=""><e path="Void"/></f></exitAU>
		<isScoAvailable public="1" set="method" line="277"><f a="identifier">
	<c path="String"/>
	<e path="Bool"/>
</f></isScoAvailable>
		<navigateToSco public="1" set="method" line="267"><f a="identifier">
	<c path="String"/>
	<e path="Bool"/>
</f></navigateToSco>
		<putparam public="1" set="method" line="246" override="1"><f a=""><e path="Void"/></f></putparam>
		<returnFormatedTime public="1" set="method" line="221"><f a=""><c path="String"/></f></returnFormatedTime>
		<getMasteryScore public="1" set="method" line="216" override="1"><f a=""><c path="Int"/></f></getMasteryScore>
		<setScore public="1" set="method" line="195" override="1"><f a="score">
	<c path="Int"/>
	<e path="Void"/>
</f></setScore>
		<setStatus public="1" set="method" line="156" override="1"><f a="status">
	<e path="Bool"/>
	<e path="Void"/>
</f></setStatus>
		<setSuccessStatus public="1" set="method" line="138"><f a="isSucces">
	<e path="Bool"/>
	<e path="Void"/>
</f></setSuccessStatus>
		<getSuccessStatus public="1" set="method" line="127"><f a=""><c path="String"/></f></getSuccessStatus>
		<getStatus public="1" set="method" line="122" override="1"><f a=""><c path="String"/></f></getStatus>
		<setSuspend public="1" set="method" line="109" override="1"><f a="suspention">
	<c path="String"/>
	<e path="Void"/>
</f></setSuspend>
		<getSuspend public="1" set="method" line="104" override="1"><f a=""><c path="String"/></f></getSuspend>
		<setLocation public="1" set="method" line="91" override="1"><f a="location">
	<c path="String"/>
	<e path="Void"/>
</f></setLocation>
		<getLocation public="1" set="method" line="86" override="1"><f a=""><c path="String"/></f></getLocation>
		<init public="1" set="method" line="48" override="1"><f a="?isNote:?activation">
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></init>
		<activation public="1" set="method" line="30" override="1"><f a="activation">
	<c path="String"/>
	<e path="Void"/>
</f></activation>
		<scorm public="1"><c path="com.knowledgeplayers.grar.tracking.Scorm"/></scorm>
		<is2004 public="1"><e path="Bool"/></is2004>
		<timer public="1"><t path="nme.utils.Timer"/></timer>
		<startTime public="1"><c path="Int"/></startTime>
		<isActive public="1"><e path="Bool"/></isActive>
		<isNote public="1"><e path="Bool"/></isNote>
		<suspend_data public="1"><c path="String"/></suspend_data>
		<lesson_location public="1"><c path="String"/></lesson_location>
		<success_status public="1"><c path="String"/></success_status>
		<new public="1" set="method" line="20"><f a="?is2004">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.knowledgeplayers.grar.tracking.StateInfos" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/tracking/StateInfos.hx">
		<toString public="1" set="method" line="48"><f a=""><c path="String"/></f></toString>
		<isEmpty public="1" set="method" line="43"><f a=""><e path="Bool"/></f></isEmpty>
		<saveStateInfos public="1" set="method" line="29"><f a=""><c path="String"/></f></saveStateInfos>
		<loadStateInfos public="1" set="method" line="15"><f a="state">
	<c path="String"/>
	<e path="Void"/>
</f></loadStateInfos>
		<checksum public="1"><c path="Int"/></checksum>
		<activityCompletion public="1"><c path="Array"><e path="Bool"/></c></activityCompletion>
		<currentActivity public="1"><c path="String"/></currentActivity>
		<currentLanguage public="1"><c path="String"/></currentLanguage>
		<new public="1" set="method" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.knowledgeplayers.grar.util.DisplayUtils" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/util/DisplayUtils.hx">
		<getPressedId public="1" set="method" line="20" static="1">
			<f a="buttonId">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get the pressed ID of a button
	 * @param	buttonId : ID of the button
	 * @return the pressed ID for this button</haxe_doc>
		</getPressedId>
		<new set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Utility class for display</haxe_doc>
	</class>
	<class path="com.knowledgeplayers.grar.util.XmlLoader" params="" file="/usr/lib/haxe/lib/grar/0,1/com/knowledgeplayers/grar/util/XmlLoader.hx">
		<extends path="flash.events.EventDispatcher"/>
		<load public="1" set="method" line="22" static="1">
			<f a="path:?listener">
				<c path="String"/>
				<f a="">
					<t path="nme.events.Event"/>
					<e path="Void"/>
				</f>
				<t path="Null"><c path="Xml"/></t>
			</f>
			<haxe_doc>* Load an XML file
	 * @param	path : path to the file
	 * @param	listener : Function to call when the file is loaded (flash only)
	 * @return the content of the file (except in flash)</haxe_doc>
		</load>
		<getXml public="1" set="method" line="41" static="1">
			<f a="event">
				<t path="nme.events.Event"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>* Extract an XML object from a Event.COMPLETE
	 * @param	event : Event dispatched by an URLloader
	 * @return the loaded XML</haxe_doc>
		</getXml>
		<onIOError set="method" line="54" static="1"><f a="error">
	<t path="nme.events.IOErrorEvent"/>
	<e path="Void"/>
</f></onIOError>
		<new set="method" line="49"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Utility class for XML loading</haxe_doc>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="54" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="86" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="119" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="147" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="162" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="206" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="82"><f a=""><e path="Void"/></f></init>
		<doInitDelay set="method" line="77"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<start set="method" line="56"><f a=""><e path="Void"/></f></start>
		<new public="1" set="method" line="48"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><e path="Bool"/></fixed>
		<length public="1"><t path="UInt"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><e path="Bool"/></stub>
		<errno public="1"><t path="UInt"/></errno>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><e path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/lib/haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<d/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<drawWithQuality public="1">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</drawWithQuality>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><c path="Int"/></width>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><c path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,5,3/flash/display/Graphics.hx" extern="1">
		<drawTiles public="1" get="inline" set="null" line="30"><f a="sheet:tileData:?smooth:?flags">
	<c path="nme.display.Tilesheet"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTiles>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><c path="Float"/></c>
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><c path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><c path="Int"/></height>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/lib/haxe/std/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Shape" params="" file="/usr/lib/haxe/std/flash/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.SimpleButton" params="" file="/usr/lib/haxe/std/flash/display/SimpleButton.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<upState public="1"><c path="flash.display.DisplayObject"/></upState>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<overState public="1"><c path="flash.display.DisplayObject"/></overState>
		<hitTestState public="1"><c path="flash.display.DisplayObject"/></hitTestState>
		<enabled public="1"><e path="Bool"/></enabled>
		<downState public="1"><c path="flash.display.DisplayObject"/></downState>
		<new public="1" set="method"><f a="?upState:?overState:?downState:?hitTestState">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<wmodeGPU public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<stageVideos public="1">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stage3Ds public="1">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<mouseLock public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<frameRate public="1"><c path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreenInteractive public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<allowsFullScreen public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode">
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<visible public="1"><e path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromByteArray public="1">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.errors.TypeError" params="" file="/usr/lib/haxe/std/flash/errors/TypeError.hx" extern="1">
		<extends path="flash.errors.Error"/>
		<meta><m n=":native"><e>TypeError</e></m></meta>
	</class>
	<class path="flash.events.TextEvent" params="" file="/usr/lib/haxe/std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<errorID public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</errorID>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.IOErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/usr/lib/haxe/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<movementY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementY>
		<movementX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementX>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<isRelatedObjectInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<delta public="1"><c path="Int"/></delta>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/usr/lib/haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><e path="Bool"/></available>
		<marshallExceptions public="1" static="1"><e path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<redOffset public="1"><c path="Float"/></redOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<color public="1"><t path="UInt"/></color>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="aa:ba:ca:da:txa:tya">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><c path="Float"/></ty>
		<tx public="1"><c path="Float"/></tx>
		<d public="1"><c path="Float"/></d>
		<c public="1"><c path="Float"/></c>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><c path="Float"/></focalLength>
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="xa:ya:widtha:heighta">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><c path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><c path="Float"/></right>
		<left public="1"><c path="Float"/></left>
		<height public="1"><c path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><c path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya:za">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<w public="1"><c path="Float"/></w>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<position public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<index public="1" set="null"><c path="Int"/></index>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="/usr/lib/haxe/std/flash/media/ID3Info.hx" extern="1">
		<year public="1"><c path="String"/></year>
		<track public="1"><c path="String"/></track>
		<songName public="1"><c path="String"/></songName>
		<genre public="1"><c path="String"/></genre>
		<comment public="1"><c path="String"/></comment>
		<artist public="1"><c path="String"/></artist>
		<album public="1"><c path="String"/></album>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1">
			<f a="?index">
				<c path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<rate public="1"><c path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<index public="1" set="null"><c path="Int"/></index>
		<gain public="1"><c path="Float"/></gain>
		<framesPerPacket public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<echoPath public="1"><c path="Int"/></echoPath>
		<autoGain public="1"><e path="Bool"/></autoGain>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.media.Sound" params="" file="/usr/lib/haxe/std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<loadPCMFromByteArray public="1">
			<f a="bytes:samples:?format:?stereo:?sampleRate">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadPCMFromByteArray>
		<loadCompressedDataFromByteArray public="1">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<extract public="1" set="method">
			<f a="target:length:?startPosition">
				<c path="flash.utils.ByteArray"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</extract>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<url public="1" set="null"><c path="String"/></url>
		<length public="1" set="null"><c path="Float"/></length>
		<isURLInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/usr/lib/haxe/std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="/usr/lib/haxe/std/flash/media/SoundLoaderContext.hx" extern="1">
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><c path="Float"/></volume>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<pan public="1"><c path="Float"/></pan>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><c path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<step public="1">
			<f a="frames">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<dispose public="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attach public="1">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<useJitterBuffer public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<useHardwareDecoder public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><c path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<backBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><c path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><c path="Float"/></len>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.net.SharedObject" params="" file="/usr/lib/haxe/std/flash/net/SharedObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<deleteAll public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></deleteAll>
		<getDiskUsage public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></getDiskUsage>
		<getLocal public="1" set="method" static="1"><f a="name:?localPath:?secure">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getLocal>
		<getRemote public="1" set="method" static="1"><f a="name:?remotePath:?persistence:?secure">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getRemote>
		<setProperty public="1" set="method"><f a="propertyName:?value">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setProperty>
		<setDirty public="1" set="method"><f a="propertyName">
	<c path="String"/>
	<e path="Void"/>
</f></setDirty>
		<send public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<flush public="1" set="method"><f a="?minDiskSpace">
	<c path="Int"/>
	<c path="String"/>
</f></flush>
		<connect public="1" set="method"><f a="myConnection:?params">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<size public="1" set="null"><t path="UInt"/></size>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<fps public="1" get="null"><c path="Float"/></fps>
		<data public="1" set="null"><d/></data>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.SharedObjectFlushStatus" params="" file="/usr/lib/haxe/std/flash/net/SharedObjectFlushStatus.hx" extern="1">
		<FLUSHED public="1" static="1"><c path="String"/></FLUSHED>
		<PENDING public="1" static="1"><c path="String"/></PENDING>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.URLLoader" params="" file="/usr/lib/haxe/std/flash/net/URLLoader.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<load public="1" set="method"><f a="request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<dataFormat public="1"><e path="flash.net.URLLoaderDataFormat"/></dataFormat>
		<data public="1"><d/></data>
		<bytesTotal public="1"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1"><t path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.net.URLLoaderDataFormat" params="" file="/usr/lib/haxe/std/flash/net/URLLoaderDataFormat.hx">
		<VARIABLES/>
		<TEXT/>
		<BINARY/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestMethod" params="" file="/usr/lib/haxe/std/flash/net/URLRequestMethod.hx" extern="1">
		<DELETE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</DELETE>
		<GET public="1" static="1"><c path="String"/></GET>
		<HEAD public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</HEAD>
		<OPTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</OPTIONS>
		<POST public="1" static="1"><c path="String"/></POST>
		<PUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</PUT>
	</class>
	<class path="flash.net.URLVariables" params="" file="/usr/lib/haxe/std/flash/net/URLVariables.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<decode public="1" set="method"><f a="source">
	<c path="String"/>
	<e path="Void"/>
</f></decode>
		<new public="1" set="method"><f a="?source">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.Font" params="" file="/usr/lib/haxe/std/flash/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.FontStyle" params="" file="/usr/lib/haxe/std/flash/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.FontType" params="" file="/usr/lib/haxe/std/flash/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<leading public="1"><c path="Float"/></leading>
		<height public="1"><c path="Float"/></height>
		<descent public="1"><c path="Float"/></descent>
		<ascent public="1"><c path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><e path="Bool"/></zoom>
		<save public="1"><e path="Bool"/></save>
		<rewind public="1"><e path="Bool"/></rewind>
		<quality public="1"><e path="Bool"/></quality>
		<print public="1"><e path="Bool"/></print>
		<play public="1"><e path="Bool"/></play>
		<loop public="1"><e path="Bool"/></loop>
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<paste public="1"><e path="Bool"/></paste>
		<cut public="1"><e path="Bool"/></cut>
		<copy public="1"><e path="Bool"/></copy>
		<clear public="1"><e path="Bool"/></clear>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<clear public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<position public="1"><t path="UInt"/></position>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<length public="1"><t path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.QName" params="" file="/usr/lib/haxe/std/flash/utils/QName.hx" extern="1">
		<uri public="1" set="null"><d/></uri>
		<localName public="1" set="null"><c path="String"/></localName>
		<new public="1" set="method"><f a="?namespace:?name">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.Timer" params="" file="/usr/lib/haxe/std/flash/utils/Timer.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<start public="1" set="method"><f a=""><e path="Void"/></f></start>
		<reset public="1" set="method"><f a=""><e path="Void"/></f></reset>
		<running public="1" set="null"><e path="Bool"/></running>
		<repeatCount public="1"><c path="Int"/></repeatCount>
		<delay public="1"><c path="Float"/></delay>
		<currentCount public="1" set="null"><c path="Int"/></currentCount>
		<new public="1" set="method"><f a="delay:?repeatCount">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="format.display.FrameLabel" params="" file="/usr/lib/haxe/lib/nme/3,5,3/format/display/FrameLabel.hx">
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method" line="11"><f a="frame:name">
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="format.display.MovieClip" params="" file="/usr/lib/haxe/lib/nme/3,5,3/format/display/MovieClip.hx">
		<extends path="flash.display.Sprite"/>
		<unflatten public="1" set="method" line="97"><f a=""><e path="Void"/></f></unflatten>
		<stop public="1" set="method" line="90"><f a=""><e path="Void"/></f></stop>
		<prevFrame public="1" set="method" line="83"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method" line="76"><f a=""><e path="Void"/></f></play>
		<nextFrame public="1" set="method" line="62"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method" line="55"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method" line="48"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<flatten public="1" set="method" line="41"><f a=""><e path="Void"/></f></flatten>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentLabels public="1" set="null"><c path="Array"><c path="format.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null"><c path="String"/></currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Base class for MovieClip-related format libraries
 * 
 * Cannot use flash.display.MovieClip, because it does
 * not allow the addition for frames or frame labels at
 * runtime, asynchronously</haxe_doc>
	</class>
	<class path="haxe.FastCell" params="T" file="/usr/lib/haxe/std/haxe/FastList.hx" module="haxe.FastList">
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="/usr/lib/haxe/std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. A different class is created for each container used in platforms where it matters</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="63" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.xml._Fast.NodeAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<resolve public="1" set="method" line="35"><f a="name">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</f></resolve>
		<__x><c path="Xml"/></__x>
		<new public="1" set="method" line="31"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.xml.Fast"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.AttribAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<resolve public="1" set="method" line="54"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></resolve>
		<__x><c path="Xml"/></__x>
		<new public="1" set="method" line="50"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasAttribAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<resolve public="1" set="method" line="73"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<__x><c path="Xml"/></__x>
		<new public="1" set="method" line="69"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasNodeAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<resolve public="1" set="method" line="89"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<__x><c path="Xml"/></__x>
		<new public="1" set="method" line="85"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.NodeListAccess" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<resolve public="1" set="method" line="103"><f a="name">
	<c path="String"/>
	<c path="List"><c path="haxe.xml.Fast"/></c>
</f></resolve>
		<__x><c path="Xml"/></__x>
		<new public="1" set="method" line="99"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="List"><c path="haxe.xml.Fast"/></c></haxe_dynamic>
	</class>
	<class path="haxe.xml.Fast" params="" file="/usr/lib/haxe/std/haxe/xml/Fast.hx">
		<getElements set="method" line="167"><f a=""><a>
	<next><f a=""><c path="haxe.xml.Fast"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></getElements>
		<getInnerHTML set="method" line="160"><f a=""><c path="String"/></f></getInnerHTML>
		<getInnerData set="method" line="140"><f a=""><c path="String"/></f></getInnerData>
		<getName set="method" line="136"><f a=""><c path="String"/></f></getName>
		<elements public="1" get="getElements" set="null"><t path="Iterator"><c path="haxe.xml.Fast"/></t></elements>
		<hasNode public="1" set="null"><c path="haxe.xml._Fast.HasNodeAccess"/></hasNode>
		<has public="1" set="null"><c path="haxe.xml._Fast.HasAttribAccess"/></has>
		<att public="1" set="null"><c path="haxe.xml._Fast.AttribAccess"/></att>
		<nodes public="1" set="null"><c path="haxe.xml._Fast.NodeListAccess"/></nodes>
		<node public="1" set="null"><c path="haxe.xml._Fast.NodeAccess"/></node>
		<innerHTML public="1" get="getInnerHTML" set="null"><c path="String"/></innerHTML>
		<innerData public="1" get="getInnerData" set="null"><c path="String"/></innerData>
		<name public="1" get="getName" set="null"><c path="String"/></name>
		<x public="1" set="null"><c path="Xml"/></x>
		<new public="1" set="method" line="125"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="nme.Assets" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/Assets.hx">
		<cachedBitmapData public="1" line="31" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<getBitmapData public="1" set="method" line="41" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<e path="Bool"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache (Default: true)
	 * @return		A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="54" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes ("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="67" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont ("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getMovieClip public="1" set="method" line="80" static="1">
			<f a="id">
				<c path="String"/>
				<c path="format.display.MovieClip"/>
			</f>
			<haxe_doc>* Gets an instance of a library MovieClip
	 * @usage		var movieClip = Assets.getMovieClip ("library:BouncingBall");
	 * @param	id		The library and ID for the MovieClip
	 * @return		A new Sound object</haxe_doc>
		</getMovieClip>
		<getSound public="1" set="method" line="93" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="106" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText ("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
	</class>
	<class path="nme.Lib" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/Lib.hx">
		<FULLSCREEN public="1" line="13" static="1"><c path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="14" static="1"><c path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="15" static="1"><c path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="16" static="1"><c path="Int"/></HARDWARE>
		<VSYNC public="1" line="17" static="1"><c path="Int"/></VSYNC>
		<HW_AA public="1" line="18" static="1"><c path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="19" static="1"><c path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="20" static="1"><c path="Int"/></ALLOW_SHADERS>
		<REQUIRE_SHADERS public="1" line="21" static="1"><c path="Int"/></REQUIRE_SHADERS>
		<DEPTH_BUFFER public="1" line="22" static="1"><c path="Int"/></DEPTH_BUFFER>
		<STENCIL_BUFFER public="1" line="23" static="1"><c path="Int"/></STENCIL_BUFFER>
		<MIN_FLOAT_VALUE public="1" line="26" static="1"><c path="Float"/></MIN_FLOAT_VALUE>
		<MAX_FLOAT_VALUE public="1" line="27" static="1"><c path="Float"/></MAX_FLOAT_VALUE>
		<company public="1" get="get_company" set="null" static="1"><c path="String"/></company>
		<current public="1" get="get_current" set="null" static="1"><t path="nme.display.MovieClip"/></current>
		<file public="1" get="get_file" set="null" static="1"><c path="String"/></file>
		<initHeight public="1" get="get_initHeight" set="null" static="1"><c path="Int"/></initHeight>
		<initWidth public="1" get="get_initWidth" set="null" static="1"><c path="Int"/></initWidth>
		<packageName public="1" get="get_packageName" set="null" static="1"><c path="String"/></packageName>
		<stage public="1" get="get_stage" set="null" static="1"><t path="nme.display.Stage"/></stage>
		<version public="1" get="get_version" set="null" static="1"><c path="String"/></version>
		<close public="1" set="method" line="50" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Closes the application.
	 * This is method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</close>
		<create public="1" set="method" line="73" static="1">
			<f a="onLoaded:width:height:?frameRate:?color:?flags:?title:?icon">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Creates a new application window. If you are using the NME
	 * command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This is method is ignored in the Flash and HTML5 targets.
	 * @param	onLoaded		A method callback that is called once the window is created.
	 * @param	width		The requested width of the window. Use a width and height of 0 to request the full screen size.
	 * @param	height		The requested height of the window. Use a width and height of 0 to request the full screen size.
	 * @param	frameRate		The requested frame rate for the application.
	 * @param	color		An RGB color to use for the application background.
	 * @param	flags		A series of bit flags which can specify windowing options, like FULLSCREEN or HARDWARE
	 * @param	title		The title to use when creating the application window.
	 * @param	icon		An icon to use for the created application window.</haxe_doc>
		</create>
		<createManagedStage public="1" set="method" line="89" static="1">
			<f a="width:height">
				<c path="Int"/>
				<c path="Int"/>
				<unknown/>
			</f>
			<haxe_doc>* Creates a managed stage, for greater control customization and control
	 * of application events.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	width		The requested width of the managed stage.
	 * @param	height		The requested width of the managed stage.</haxe_doc>
		</createManagedStage>
		<exit public="1" set="method" line="105" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Similar to the <code>close()</code> method, but the current 
	 * <code>Stage</code> object is given an opportunity to handle 
	 * the quit event before the application process is ended.
	 * This method is ignored in the Flash and HTML5 targets.]]></haxe_doc>
		</exit>
		<forceClose public="1" set="method" line="119" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Terminates the application process immediately without
	 * performing a clean shutdown.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</forceClose>
		<getTimer public="1" get="inline" set="null" line="137" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Returns the time in milliseconds, relative to the start of
	 * the application. This is a high performance call in order to 
	 * help regulate time-based operations. Depending upon the
	 * target platform, this value may or may not be an absolute
	 * timestamp. If you need an exact time, you should use the
	 * <code>Date</code> object.
	 * @return		A relative time value in milliseconds.]]></haxe_doc>
		</getTimer>
		<getURL public="1" set="method" line="156" static="1">
			<f a="url:?target">
				<t path="nme.net.URLRequest"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Opens a browser window with the specified URL. 
	 * @param	url		The URL to open.
	 * @param	target		An optional window target value.</haxe_doc>
		</getURL>
		<pause public="1" set="method" line="175" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* For supported platforms, the NME application will be
	 * paused. This can help improve response times if fullscreen
	 * native UI element is being used temporarily.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</pause>
		<postUICallback public="1" set="method" line="193" static="1">
			<f a="handler">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>* For some target platforms, NME operates on a separate thread
	 * than the native application UI. In these cases, you can use this
	 * method to make thread-safe calls to the native UI.
	 * 
	 * If the platform does not require thread-safe callbacks, the 
	 * handler method will be called immediately.
	 * @param	handler		The method handler you wish to call when the UI is available.</haxe_doc>
		</postUICallback>
		<resume public="1" set="method" line="210" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resumes the NME application. For certain platforms,
	 * pausing the application can improve response times when
	 * a fullscreen native UI element is being displayed.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</resume>
		<setPackage public="1" set="method" line="229" static="1">
			<f a="company:file:packageName:version">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Specifies meta-data for the running application. If you are using 
	 * the NME command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	company		The company name for the application.
	 * @param	file		The file name for the application.
	 * @param	packageName		The package name of the application.
	 * @param	version		The version string of the application.</haxe_doc>
		</setPackage>
		<trace public="1" set="method" line="242" static="1">
			<f a="arg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sends a <code>trace</code> call for the current platform.
	 * @param	arg]]></haxe_doc>
		</trace>
		<get_company set="method" line="261" static="1"><f a=""><c path="String"/></f></get_company>
		<get_current set="method" line="271" static="1"><f a=""><t path="nme.display.MovieClip"/></f></get_current>
		<get_file set="method" line="285" static="1"><f a=""><c path="String"/></f></get_file>
		<get_initHeight set="method" line="295" static="1"><f a=""><c path="Int"/></f></get_initHeight>
		<get_initWidth set="method" line="305" static="1"><f a=""><c path="Int"/></f></get_initWidth>
		<get_packageName set="method" line="315" static="1"><f a=""><c path="String"/></f></get_packageName>
		<get_stage set="method" line="325" static="1"><f a=""><t path="nme.display.Stage"/></f></get_stage>
		<get_version set="method" line="337" static="1"><f a=""><c path="String"/></f></get_version>
	</class>
	<typedef path="nme.Vector" params="T" file="/usr/lib/haxe/lib/nme/3,5,3/nme/Vector.hx"><c path="flash.Vector"><c path="nme.Vector.T"/></c></typedef>
	<typedef path="nme.display.Bitmap" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/Bitmap.hx"><c path="flash.display.Bitmap"/></typedef>
	<typedef path="nme.display.BitmapData" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/BitmapData.hx"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="nme.display.BlendMode" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/BlendMode.hx"><e path="flash.display.BlendMode"/></typedef>
	<typedef path="nme.display.DisplayObject" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/DisplayObject.hx"><c path="flash.display.DisplayObject"/></typedef>
	<typedef path="nme.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/DisplayObjectContainer.hx"><c path="flash.display.DisplayObjectContainer"/></typedef>
	<typedef path="nme.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/Graphics.hx"><c path="flash.display.Graphics"/></typedef>
	<typedef path="nme.display.MovieClip" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/MovieClip.hx"><c path="flash.display.MovieClip"/></typedef>
	<typedef path="nme.display.SimpleButton" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/SimpleButton.hx"><c path="flash.display.SimpleButton"/></typedef>
	<typedef path="nme.display.Sprite" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/Sprite.hx"><c path="flash.display.Sprite"/></typedef>
	<typedef path="nme.display.Stage" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/display/Stage.hx"><c path="flash.display.Stage"/></typedef>
	<typedef path="nme.errors.Error" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/errors/Error.hx"><c path="flash.errors.Error"/></typedef>
	<typedef path="nme.events.Event" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/events/Event.hx"><c path="flash.events.Event"/></typedef>
	<typedef path="nme.events.EventDispatcher" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/events/EventDispatcher.hx"><c path="flash.events.EventDispatcher"/></typedef>
	<typedef path="nme.events.IEventDispatcher" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/events/IEventDispatcher.hx"><c path="flash.events.IEventDispatcher"/></typedef>
	<typedef path="nme.events.IOErrorEvent" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/events/IOErrorEvent.hx"><c path="flash.events.IOErrorEvent"/></typedef>
	<typedef path="nme.events.MouseEvent" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/events/MouseEvent.hx"><c path="flash.events.MouseEvent"/></typedef>
	<typedef path="nme.external.ExternalInterface" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/external/ExternalInterface.hx"><c path="flash.external.ExternalInterface"/></typedef>
	<typedef path="nme.geom.Matrix" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/geom/Matrix.hx"><c path="flash.geom.Matrix"/></typedef>
	<typedef path="nme.geom.Point" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/geom/Point.hx"><c path="flash.geom.Point"/></typedef>
	<typedef path="nme.geom.Rectangle" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/geom/Rectangle.hx"><c path="flash.geom.Rectangle"/></typedef>
	<typedef path="nme.media.Sound" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/media/Sound.hx"><c path="flash.media.Sound"/></typedef>
	<typedef path="nme.media.SoundChannel" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/media/SoundChannel.hx"><c path="flash.media.SoundChannel"/></typedef>
	<typedef path="nme.net.SharedObject" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/net/SharedObject.hx"><c path="flash.net.SharedObject"/></typedef>
	<typedef path="nme.net.SharedObjectFlushStatus" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/net/SharedObjectFlushStatus.hx"><c path="flash.net.SharedObjectFlushStatus"/></typedef>
	<typedef path="nme.net.URLLoader" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/net/URLLoader.hx"><c path="flash.net.URLLoader"/></typedef>
	<typedef path="nme.net.URLLoaderDataFormat" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/net/URLLoaderDataFormat.hx"><e path="flash.net.URLLoaderDataFormat"/></typedef>
	<typedef path="nme.net.URLRequest" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/net/URLRequest.hx"><c path="flash.net.URLRequest"/></typedef>
	<typedef path="nme.net.URLRequestMethod" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/net/URLRequestMethod.hx"><c path="flash.net.URLRequestMethod"/></typedef>
	<typedef path="nme.net.URLVariables" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/net/URLVariables.hx"><c path="flash.net.URLVariables"/></typedef>
	<typedef path="nme.text.Font" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/text/Font.hx"><c path="flash.text.Font"/></typedef>
	<typedef path="nme.text.TextField" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/text/TextField.hx"><c path="flash.text.TextField"/></typedef>
	<typedef path="nme.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/text/TextFieldAutoSize.hx"><e path="flash.text.TextFieldAutoSize"/></typedef>
	<typedef path="nme.text.TextFormat" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/text/TextFormat.hx"><c path="flash.text.TextFormat"/></typedef>
	<typedef path="nme.utils.ByteArray" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/utils/ByteArray.hx"><c path="flash.utils.ByteArray"/></typedef>
	<typedef path="nme.utils.Timer" params="" file="/usr/lib/haxe/lib/nme/3,5,3/nme/utils/Timer.hx"><c path="flash.utils.Timer"/></typedef>
</haxe>